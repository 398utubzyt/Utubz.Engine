// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Utubz.Internal.Native.Bass
{
    internal delegate void FILECLOSEPROC(__IntPtr user);
    internal delegate ulong FILELENPROC(__IntPtr user);
    internal delegate uint FILEREADPROC(__IntPtr buffer, uint length, __IntPtr user);
    internal delegate int FILESEEKPROC(ulong offset, __IntPtr user);

    internal unsafe partial class BASS_DEVICEINFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal __IntPtr driver;
            internal uint flags;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DEVICEINFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO>();

        private bool __name_OwnsNativeMemory = false;
        private bool __driver_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static BASS_DEVICEINFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DEVICEINFO(native.ToPointer(), skipVTables);
        }

        internal static BASS_DEVICEINFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DEVICEINFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DEVICEINFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DEVICEINFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DEVICEINFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DEVICEINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DEVICEINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DEVICEINFO(global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO.__Internal*)__0.__Instance);
            if (__0.__name_OwnsNativeMemory)
                this.Name = __0.Name;
            if (__0.__driver_OwnsNativeMemory)
                this.Driver = __0.Driver;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__driver_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->driver);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Name
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr)__bytePtr0;
            }
        }

        public string Driver
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->driver);
            }

            set
            {
                if (__driver_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->driver);
                __driver_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->driver = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->driver = (__IntPtr)__bytePtr0;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }
    }

    internal unsafe partial class BASS_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal uint flags;
            internal uint hwsize;
            internal uint hwfree;
            internal uint freesam;
            internal uint free3d;
            internal uint minrate;
            internal uint maxrate;
            internal int eax;
            internal uint minbuf;
            internal uint dsver;
            internal uint latency;
            internal uint initflags;
            internal uint speakers;
            internal uint freq;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_INFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_INFO>();

        protected bool __ownsNativeInstance;

        internal static BASS_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_INFO(native.ToPointer(), skipVTables);
        }

        internal static BASS_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_INFO(global::Utubz.Internal.Native.Bass.BASS_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_INFO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_INFO.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint Hwsize
        {
            get
            {
                return ((__Internal*)__Instance)->hwsize;
            }

            set
            {
                ((__Internal*)__Instance)->hwsize = value;
            }
        }

        public uint Hwfree
        {
            get
            {
                return ((__Internal*)__Instance)->hwfree;
            }

            set
            {
                ((__Internal*)__Instance)->hwfree = value;
            }
        }

        public uint Freesam
        {
            get
            {
                return ((__Internal*)__Instance)->freesam;
            }

            set
            {
                ((__Internal*)__Instance)->freesam = value;
            }
        }

        public uint Free3d
        {
            get
            {
                return ((__Internal*)__Instance)->free3d;
            }

            set
            {
                ((__Internal*)__Instance)->free3d = value;
            }
        }

        public uint Minrate
        {
            get
            {
                return ((__Internal*)__Instance)->minrate;
            }

            set
            {
                ((__Internal*)__Instance)->minrate = value;
            }
        }

        public uint Maxrate
        {
            get
            {
                return ((__Internal*)__Instance)->maxrate;
            }

            set
            {
                ((__Internal*)__Instance)->maxrate = value;
            }
        }

        public int Eax
        {
            get
            {
                return ((__Internal*)__Instance)->eax;
            }

            set
            {
                ((__Internal*)__Instance)->eax = value;
            }
        }

        public uint Minbuf
        {
            get
            {
                return ((__Internal*)__Instance)->minbuf;
            }

            set
            {
                ((__Internal*)__Instance)->minbuf = value;
            }
        }

        public uint Dsver
        {
            get
            {
                return ((__Internal*)__Instance)->dsver;
            }

            set
            {
                ((__Internal*)__Instance)->dsver = value;
            }
        }

        public uint Latency
        {
            get
            {
                return ((__Internal*)__Instance)->latency;
            }

            set
            {
                ((__Internal*)__Instance)->latency = value;
            }
        }

        public uint Initflags
        {
            get
            {
                return ((__Internal*)__Instance)->initflags;
            }

            set
            {
                ((__Internal*)__Instance)->initflags = value;
            }
        }

        public uint Speakers
        {
            get
            {
                return ((__Internal*)__Instance)->speakers;
            }

            set
            {
                ((__Internal*)__Instance)->speakers = value;
            }
        }

        public uint Freq
        {
            get
            {
                return ((__Internal*)__Instance)->freq;
            }

            set
            {
                ((__Internal*)__Instance)->freq = value;
            }
        }
    }

    internal unsafe partial class BASS_RECORDINFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal uint flags;
            internal uint formats;
            internal uint inputs;
            internal int singlein;
            internal uint freq;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_RECORDINFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_RECORDINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_RECORDINFO>();

        protected bool __ownsNativeInstance;

        internal static BASS_RECORDINFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_RECORDINFO(native.ToPointer(), skipVTables);
        }

        internal static BASS_RECORDINFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_RECORDINFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_RECORDINFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_RECORDINFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_RECORDINFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_RECORDINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_RECORDINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_RECORDINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_RECORDINFO(global::Utubz.Internal.Native.Bass.BASS_RECORDINFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_RECORDINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_RECORDINFO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_RECORDINFO.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint Formats
        {
            get
            {
                return ((__Internal*)__Instance)->formats;
            }

            set
            {
                ((__Internal*)__Instance)->formats = value;
            }
        }

        public uint Inputs
        {
            get
            {
                return ((__Internal*)__Instance)->inputs;
            }

            set
            {
                ((__Internal*)__Instance)->inputs = value;
            }
        }

        public int Singlein
        {
            get
            {
                return ((__Internal*)__Instance)->singlein;
            }

            set
            {
                ((__Internal*)__Instance)->singlein = value;
            }
        }

        public uint Freq
        {
            get
            {
                return ((__Internal*)__Instance)->freq;
            }

            set
            {
                ((__Internal*)__Instance)->freq = value;
            }
        }
    }

    internal unsafe partial class BASS_SAMPLE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 68)]
        public partial struct __Internal
        {
            internal uint freq;
            internal float volume;
            internal float pan;
            internal uint flags;
            internal uint length;
            internal uint max;
            internal uint origres;
            internal uint chans;
            internal uint mingap;
            internal uint mode3d;
            internal float mindist;
            internal float maxdist;
            internal uint iangle;
            internal uint oangle;
            internal float outvol;
            internal uint vam;
            internal uint priority;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_SAMPLE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_SAMPLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_SAMPLE>();

        protected bool __ownsNativeInstance;

        internal static BASS_SAMPLE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_SAMPLE(native.ToPointer(), skipVTables);
        }

        internal static BASS_SAMPLE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_SAMPLE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_SAMPLE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_SAMPLE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_SAMPLE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_SAMPLE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_SAMPLE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_SAMPLE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_SAMPLE(global::Utubz.Internal.Native.Bass.BASS_SAMPLE __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_SAMPLE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_SAMPLE.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_SAMPLE.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Freq
        {
            get
            {
                return ((__Internal*)__Instance)->freq;
            }

            set
            {
                ((__Internal*)__Instance)->freq = value;
            }
        }

        public float Volume
        {
            get
            {
                return ((__Internal*)__Instance)->volume;
            }

            set
            {
                ((__Internal*)__Instance)->volume = value;
            }
        }

        public float Pan
        {
            get
            {
                return ((__Internal*)__Instance)->pan;
            }

            set
            {
                ((__Internal*)__Instance)->pan = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        public uint Max
        {
            get
            {
                return ((__Internal*)__Instance)->max;
            }

            set
            {
                ((__Internal*)__Instance)->max = value;
            }
        }

        public uint Origres
        {
            get
            {
                return ((__Internal*)__Instance)->origres;
            }

            set
            {
                ((__Internal*)__Instance)->origres = value;
            }
        }

        public uint Chans
        {
            get
            {
                return ((__Internal*)__Instance)->chans;
            }

            set
            {
                ((__Internal*)__Instance)->chans = value;
            }
        }

        public uint Mingap
        {
            get
            {
                return ((__Internal*)__Instance)->mingap;
            }

            set
            {
                ((__Internal*)__Instance)->mingap = value;
            }
        }

        public uint Mode3d
        {
            get
            {
                return ((__Internal*)__Instance)->mode3d;
            }

            set
            {
                ((__Internal*)__Instance)->mode3d = value;
            }
        }

        public float Mindist
        {
            get
            {
                return ((__Internal*)__Instance)->mindist;
            }

            set
            {
                ((__Internal*)__Instance)->mindist = value;
            }
        }

        public float Maxdist
        {
            get
            {
                return ((__Internal*)__Instance)->maxdist;
            }

            set
            {
                ((__Internal*)__Instance)->maxdist = value;
            }
        }

        public uint Iangle
        {
            get
            {
                return ((__Internal*)__Instance)->iangle;
            }

            set
            {
                ((__Internal*)__Instance)->iangle = value;
            }
        }

        public uint Oangle
        {
            get
            {
                return ((__Internal*)__Instance)->oangle;
            }

            set
            {
                ((__Internal*)__Instance)->oangle = value;
            }
        }

        public float Outvol
        {
            get
            {
                return ((__Internal*)__Instance)->outvol;
            }

            set
            {
                ((__Internal*)__Instance)->outvol = value;
            }
        }

        public uint Vam
        {
            get
            {
                return ((__Internal*)__Instance)->vam;
            }

            set
            {
                ((__Internal*)__Instance)->vam = value;
            }
        }

        public uint Priority
        {
            get
            {
                return ((__Internal*)__Instance)->priority;
            }

            set
            {
                ((__Internal*)__Instance)->priority = value;
            }
        }
    }

    internal unsafe partial class BASS_CHANNELINFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint freq;
            internal uint chans;
            internal uint flags;
            internal uint ctype;
            internal uint origres;
            internal uint plugin;
            internal uint sample;
            internal __IntPtr filename;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_CHANNELINFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO>();

        private bool __filename_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static BASS_CHANNELINFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_CHANNELINFO(native.ToPointer(), skipVTables);
        }

        internal static BASS_CHANNELINFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_CHANNELINFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_CHANNELINFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_CHANNELINFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_CHANNELINFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_CHANNELINFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_CHANNELINFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_CHANNELINFO(global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO.__Internal*)__0.__Instance);
            if (__0.__filename_OwnsNativeMemory)
                this.Filename = __0.Filename;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__filename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->filename);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Freq
        {
            get
            {
                return ((__Internal*)__Instance)->freq;
            }

            set
            {
                ((__Internal*)__Instance)->freq = value;
            }
        }

        public uint Chans
        {
            get
            {
                return ((__Internal*)__Instance)->chans;
            }

            set
            {
                ((__Internal*)__Instance)->chans = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint Ctype
        {
            get
            {
                return ((__Internal*)__Instance)->ctype;
            }

            set
            {
                ((__Internal*)__Instance)->ctype = value;
            }
        }

        public uint Origres
        {
            get
            {
                return ((__Internal*)__Instance)->origres;
            }

            set
            {
                ((__Internal*)__Instance)->origres = value;
            }
        }

        public uint Plugin
        {
            get
            {
                return ((__Internal*)__Instance)->plugin;
            }

            set
            {
                ((__Internal*)__Instance)->plugin = value;
            }
        }

        public uint Sample
        {
            get
            {
                return ((__Internal*)__Instance)->sample;
            }

            set
            {
                ((__Internal*)__Instance)->sample = value;
            }
        }

        public string Filename
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->filename);
            }

            set
            {
                if (__filename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->filename);
                __filename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->filename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->filename = (__IntPtr)__bytePtr0;
            }
        }
    }

    internal unsafe partial class BASS_PLUGINFORM : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint ctype;
            internal __IntPtr name;
            internal __IntPtr exts;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_PLUGINFORM@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM>();

        private bool __name_OwnsNativeMemory = false;
        private bool __exts_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static BASS_PLUGINFORM __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_PLUGINFORM(native.ToPointer(), skipVTables);
        }

        internal static BASS_PLUGINFORM __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_PLUGINFORM)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_PLUGINFORM __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_PLUGINFORM(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_PLUGINFORM(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_PLUGINFORM(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_PLUGINFORM()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_PLUGINFORM(global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM.__Internal*)__0.__Instance);
            if (__0.__name_OwnsNativeMemory)
                this.Name = __0.Name;
            if (__0.__exts_OwnsNativeMemory)
                this.Exts = __0.Exts;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__exts_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->exts);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Ctype
        {
            get
            {
                return ((__Internal*)__Instance)->ctype;
            }

            set
            {
                ((__Internal*)__Instance)->ctype = value;
            }
        }

        public string Name
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr)__bytePtr0;
            }
        }

        public string Exts
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->exts);
            }

            set
            {
                if (__exts_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->exts);
                __exts_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->exts = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->exts = (__IntPtr)__bytePtr0;
            }
        }
    }

    internal unsafe partial class BASS_PLUGININFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint version;
            internal uint formatc;
            internal __IntPtr formats;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_PLUGININFO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_PLUGININFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_PLUGININFO>();

        protected bool __ownsNativeInstance;

        internal static BASS_PLUGININFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_PLUGININFO(native.ToPointer(), skipVTables);
        }

        internal static BASS_PLUGININFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_PLUGININFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_PLUGININFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_PLUGININFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_PLUGININFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_PLUGININFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_PLUGININFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_PLUGININFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_PLUGININFO(global::Utubz.Internal.Native.Bass.BASS_PLUGININFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_PLUGININFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_PLUGININFO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_PLUGININFO.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public uint Formatc
        {
            get
            {
                return ((__Internal*)__Instance)->formatc;
            }

            set
            {
                ((__Internal*)__Instance)->formatc = value;
            }
        }

        public global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM Formats
        {
            get
            {
                var __result0 = global::Utubz.Internal.Native.Bass.BASS_PLUGINFORM.__GetOrCreateInstance(((__Internal*)__Instance)->formats, false);
                return __result0;
            }
        }
    }

    internal unsafe partial class BASS_3DVECTOR : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;
            internal float z;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_3DVECTOR@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_3DVECTOR@@QEAA@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float _x, float _y, float _z);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_3DVECTOR@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR>();

        protected bool __ownsNativeInstance;

        internal static BASS_3DVECTOR __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_3DVECTOR(native.ToPointer(), skipVTables);
        }

        internal static BASS_3DVECTOR __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_3DVECTOR)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_3DVECTOR __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_3DVECTOR(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_3DVECTOR(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_3DVECTOR(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_3DVECTOR()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public BASS_3DVECTOR(float _x, float _y, float _z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, _x, _y, _z);
        }

        public BASS_3DVECTOR(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_3DVECTOR.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_3DVECTOR.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }
    }

    internal unsafe partial class BASS_FILEPROCS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr close;
            internal __IntPtr length;
            internal __IntPtr read;
            internal __IntPtr seek;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_FILEPROCS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_FILEPROCS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_FILEPROCS>();

        protected bool __ownsNativeInstance;

        internal static BASS_FILEPROCS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_FILEPROCS(native.ToPointer(), skipVTables);
        }

        internal static BASS_FILEPROCS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_FILEPROCS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_FILEPROCS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_FILEPROCS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_FILEPROCS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_FILEPROCS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_FILEPROCS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_FILEPROCS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_FILEPROCS(global::Utubz.Internal.Native.Bass.BASS_FILEPROCS __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_FILEPROCS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_FILEPROCS.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_FILEPROCS.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public FILECLOSEPROC Close
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->close;
                return __ptr0 == IntPtr.Zero ? null : (FILECLOSEPROC)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(FILECLOSEPROC));
            }

            set
            {
                ((__Internal*)__Instance)->close = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public FILELENPROC Length
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->length;
                return __ptr0 == IntPtr.Zero ? null : (FILELENPROC)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(FILELENPROC));
            }

            set
            {
                ((__Internal*)__Instance)->length = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public FILEREADPROC Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero ? null : (FILEREADPROC)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(FILEREADPROC));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public FILESEEKPROC Seek
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->seek;
                return __ptr0 == IntPtr.Zero ? null : (FILESEEKPROC)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(FILESEEKPROC));
            }

            set
            {
                ((__Internal*)__Instance)->seek = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    internal unsafe partial class TAG_ID3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 128)]
        public partial struct __Internal
        {
            internal fixed sbyte id[3];
            internal fixed sbyte title[30];
            internal fixed sbyte artist[30];
            internal fixed sbyte album[30];
            internal fixed sbyte year[4];
            internal fixed sbyte comment[30];
            internal byte genre;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_ID3@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_ID3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_ID3>();

        protected bool __ownsNativeInstance;

        internal static TAG_ID3 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_ID3(native.ToPointer(), skipVTables);
        }

        internal static TAG_ID3 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_ID3)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_ID3 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_ID3(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_ID3(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_ID3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_ID3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_ID3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_ID3(global::Utubz.Internal.Native.Bass.TAG_ID3 __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_ID3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_ID3.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_ID3.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Id
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->id, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->id[i] = value[i];
                }
            }
        }

        public sbyte[] Title
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->title, 30);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 30; i++)
                        ((__Internal*)__Instance)->title[i] = value[i];
                }
            }
        }

        public sbyte[] Artist
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->artist, 30);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 30; i++)
                        ((__Internal*)__Instance)->artist[i] = value[i];
                }
            }
        }

        public sbyte[] Album
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->album, 30);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 30; i++)
                        ((__Internal*)__Instance)->album[i] = value[i];
                }
            }
        }

        public sbyte[] Year
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->year, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->year[i] = value[i];
                }
            }
        }

        public sbyte[] Comment
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->comment, 30);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 30; i++)
                        ((__Internal*)__Instance)->comment[i] = value[i];
                }
            }
        }

        public byte Genre
        {
            get
            {
                return ((__Internal*)__Instance)->genre;
            }

            set
            {
                ((__Internal*)__Instance)->genre = value;
            }
        }
    }

    internal unsafe partial class TAG_APE_BINARY : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr data;
            internal uint length;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_APE_BINARY@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_APE_BINARY> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_APE_BINARY>();

        private bool __key_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static TAG_APE_BINARY __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_APE_BINARY(native.ToPointer(), skipVTables);
        }

        internal static TAG_APE_BINARY __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_APE_BINARY)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_APE_BINARY __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_APE_BINARY(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_APE_BINARY(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_APE_BINARY(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_APE_BINARY()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_APE_BINARY.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_APE_BINARY(global::Utubz.Internal.Native.Bass.TAG_APE_BINARY __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_APE_BINARY.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_APE_BINARY.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_APE_BINARY.__Internal*)__0.__Instance);
            if (__0.__key_OwnsNativeMemory)
                this.Key = __0.Key;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__key_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->key);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                if (__key_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->key);
                __key_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->key = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->key = (__IntPtr)__bytePtr0;
            }
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->data;
            }
        }

        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }
    }

    internal unsafe partial class TAG_BEXT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 602, Pack = 1)]
        public partial struct __Internal
        {
            internal fixed sbyte Description[256];
            internal fixed sbyte Originator[32];
            internal fixed sbyte OriginatorReference[32];
            internal fixed sbyte OriginationDate[10];
            internal fixed sbyte OriginationTime[8];
            internal ulong TimeReference;
            internal ushort Version;
            internal fixed byte UMID[64];
            internal fixed byte Reserved[190];
            internal __IntPtr CodingHistory;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_BEXT@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_BEXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_BEXT>();

        protected bool __ownsNativeInstance;

        internal static TAG_BEXT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_BEXT(native.ToPointer(), skipVTables);
        }

        internal static TAG_BEXT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_BEXT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_BEXT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_BEXT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_BEXT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_BEXT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_BEXT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_BEXT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_BEXT(global::Utubz.Internal.Native.Bass.TAG_BEXT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_BEXT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_BEXT.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_BEXT.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Description
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Description, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->Description[i] = value[i];
                }
            }
        }

        public sbyte[] Originator
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Originator, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->Originator[i] = value[i];
                }
            }
        }

        public sbyte[] OriginatorReference
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->OriginatorReference, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->OriginatorReference[i] = value[i];
                }
            }
        }

        public sbyte[] OriginationDate
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->OriginationDate, 10);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 10; i++)
                        ((__Internal*)__Instance)->OriginationDate[i] = value[i];
                }
            }
        }

        public sbyte[] OriginationTime
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->OriginationTime, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->OriginationTime[i] = value[i];
                }
            }
        }

        public ulong TimeReference
        {
            get
            {
                return ((__Internal*)__Instance)->TimeReference;
            }

            set
            {
                ((__Internal*)__Instance)->TimeReference = value;
            }
        }

        public ushort Version
        {
            get
            {
                return ((__Internal*)__Instance)->Version;
            }

            set
            {
                ((__Internal*)__Instance)->Version = value;
            }
        }

        public byte[] UMID
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->UMID, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->UMID[i] = value[i];
                }
            }
        }

        public byte[] Reserved
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Reserved, 190);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 190; i++)
                        ((__Internal*)__Instance)->Reserved[i] = value[i];
                }
            }
        }

        public byte[] CodingHistory
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<byte>((void*)((__Internal*)__Instance)->CodingHistory, 0);
            }

            set
            {
                Marshal.Copy(value, 0, ((__Internal*)__Instance)->CodingHistory, value.Length);
            }
        }
    }

    internal unsafe partial class TAG_CART_TIMER : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint dwUsage;
            internal uint dwValue;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_CART_TIMER@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CART_TIMER> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CART_TIMER>();

        protected bool __ownsNativeInstance;

        internal static TAG_CART_TIMER __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_CART_TIMER(native.ToPointer(), skipVTables);
        }

        internal static TAG_CART_TIMER __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_CART_TIMER)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_CART_TIMER __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_CART_TIMER(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_CART_TIMER(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_CART_TIMER(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_CART_TIMER()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_CART_TIMER(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwUsage
        {
            get
            {
                return ((__Internal*)__Instance)->dwUsage;
            }

            set
            {
                ((__Internal*)__Instance)->dwUsage = value;
            }
        }

        public uint DwValue
        {
            get
            {
                return ((__Internal*)__Instance)->dwValue;
            }

            set
            {
                ((__Internal*)__Instance)->dwValue = value;
            }
        }
    }

    internal unsafe partial class TAG_CART : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2048)]
        public partial struct __Internal
        {
            internal fixed sbyte Version[4];
            internal fixed sbyte Title[64];
            internal fixed sbyte Artist[64];
            internal fixed sbyte CutID[64];
            internal fixed sbyte ClientID[64];
            internal fixed sbyte Category[64];
            internal fixed sbyte Classification[64];
            internal fixed sbyte OutCue[64];
            internal fixed sbyte StartDate[10];
            internal fixed sbyte StartTime[8];
            internal fixed sbyte EndDate[10];
            internal fixed sbyte EndTime[8];
            internal fixed sbyte ProducerAppID[64];
            internal fixed sbyte ProducerAppVersion[64];
            internal fixed sbyte UserDef[64];
            internal uint dwLevelReference;
            internal fixed byte PostTimer[64];
            internal fixed sbyte Reserved[276];
            internal fixed sbyte URL[1024];
            internal __IntPtr TagText;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_CART@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CART> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CART>();

        protected bool __ownsNativeInstance;

        internal static TAG_CART __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_CART(native.ToPointer(), skipVTables);
        }

        internal static TAG_CART __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_CART)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_CART __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_CART(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_CART(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_CART(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_CART()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CART.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_CART(global::Utubz.Internal.Native.Bass.TAG_CART __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CART.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_CART.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_CART.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Version
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Version, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->Version[i] = value[i];
                }
            }
        }

        public sbyte[] Title
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Title, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->Title[i] = value[i];
                }
            }
        }

        public sbyte[] Artist
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Artist, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->Artist[i] = value[i];
                }
            }
        }

        public sbyte[] CutID
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->CutID, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->CutID[i] = value[i];
                }
            }
        }

        public sbyte[] ClientID
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->ClientID, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->ClientID[i] = value[i];
                }
            }
        }

        public sbyte[] Category
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Category, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->Category[i] = value[i];
                }
            }
        }

        public sbyte[] Classification
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Classification, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->Classification[i] = value[i];
                }
            }
        }

        public sbyte[] OutCue
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->OutCue, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->OutCue[i] = value[i];
                }
            }
        }

        public sbyte[] StartDate
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->StartDate, 10);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 10; i++)
                        ((__Internal*)__Instance)->StartDate[i] = value[i];
                }
            }
        }

        public sbyte[] StartTime
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->StartTime, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->StartTime[i] = value[i];
                }
            }
        }

        public sbyte[] EndDate
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->EndDate, 10);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 10; i++)
                        ((__Internal*)__Instance)->EndDate[i] = value[i];
                }
            }
        }

        public sbyte[] EndTime
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->EndTime, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->EndTime[i] = value[i];
                }
            }
        }

        public sbyte[] ProducerAppID
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->ProducerAppID, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->ProducerAppID[i] = value[i];
                }
            }
        }

        public sbyte[] ProducerAppVersion
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->ProducerAppVersion, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->ProducerAppVersion[i] = value[i];
                }
            }
        }

        public sbyte[] UserDef
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->UserDef, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->UserDef[i] = value[i];
                }
            }
        }

        public uint DwLevelReference
        {
            get
            {
                return ((__Internal*)__Instance)->dwLevelReference;
            }

            set
            {
                ((__Internal*)__Instance)->dwLevelReference = value;
            }
        }

        public global::Utubz.Internal.Native.Bass.TAG_CART_TIMER[] PostTimer
        {
            get
            {
                global::Utubz.Internal.Native.Bass.TAG_CART_TIMER[] __value = null;
                if (((__Internal*)__Instance)->PostTimer != null)
                {
                    __value = new global::Utubz.Internal.Native.Bass.TAG_CART_TIMER[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__GetOrCreateInstance((IntPtr)((global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal*)&(((__Internal*)__Instance)->PostTimer[i * sizeof(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal*)&((__Internal*)__Instance)->PostTimer[i * sizeof(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal)] = *(global::Utubz.Internal.Native.Bass.TAG_CART_TIMER.__Internal*)value[i].__Instance;
                }
            }
        }

        public sbyte[] Reserved
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Reserved, 276);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 276; i++)
                        ((__Internal*)__Instance)->Reserved[i] = value[i];
                }
            }
        }

        public sbyte[] URL
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->URL, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->URL[i] = value[i];
                }
            }
        }

        public byte[] TagText
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<byte>((void*)((__Internal*)__Instance)->TagText, 0);
            }

            set
            {
                Marshal.Copy(value, 0, ((__Internal*)__Instance)->TagText, value.Length);
            }
        }
    }

    internal unsafe partial class TAG_CUE_POINT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint dwName;
            internal uint dwPosition;
            internal uint fccChunk;
            internal uint dwChunkStart;
            internal uint dwBlockStart;
            internal uint dwSampleOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_CUE_POINT@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CUE_POINT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CUE_POINT>();

        protected bool __ownsNativeInstance;

        internal static TAG_CUE_POINT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_CUE_POINT(native.ToPointer(), skipVTables);
        }

        internal static TAG_CUE_POINT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_CUE_POINT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_CUE_POINT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_CUE_POINT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_CUE_POINT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_CUE_POINT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_CUE_POINT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_CUE_POINT(global::Utubz.Internal.Native.Bass.TAG_CUE_POINT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwName
        {
            get
            {
                return ((__Internal*)__Instance)->dwName;
            }

            set
            {
                ((__Internal*)__Instance)->dwName = value;
            }
        }

        public uint DwPosition
        {
            get
            {
                return ((__Internal*)__Instance)->dwPosition;
            }

            set
            {
                ((__Internal*)__Instance)->dwPosition = value;
            }
        }

        public uint FccChunk
        {
            get
            {
                return ((__Internal*)__Instance)->fccChunk;
            }

            set
            {
                ((__Internal*)__Instance)->fccChunk = value;
            }
        }

        public uint DwChunkStart
        {
            get
            {
                return ((__Internal*)__Instance)->dwChunkStart;
            }

            set
            {
                ((__Internal*)__Instance)->dwChunkStart = value;
            }
        }

        public uint DwBlockStart
        {
            get
            {
                return ((__Internal*)__Instance)->dwBlockStart;
            }

            set
            {
                ((__Internal*)__Instance)->dwBlockStart = value;
            }
        }

        public uint DwSampleOffset
        {
            get
            {
                return ((__Internal*)__Instance)->dwSampleOffset;
            }

            set
            {
                ((__Internal*)__Instance)->dwSampleOffset = value;
            }
        }
    }

    internal unsafe partial class TAG_CUE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint dwCuePoints;
            internal __IntPtr CuePoints;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_CUE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CUE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CUE>();

        protected bool __ownsNativeInstance;

        internal static TAG_CUE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_CUE(native.ToPointer(), skipVTables);
        }

        internal static TAG_CUE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_CUE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_CUE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_CUE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_CUE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_CUE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_CUE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CUE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_CUE(global::Utubz.Internal.Native.Bass.TAG_CUE __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CUE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_CUE.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_CUE.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwCuePoints
        {
            get
            {
                return ((__Internal*)__Instance)->dwCuePoints;
            }

            set
            {
                ((__Internal*)__Instance)->dwCuePoints = value;
            }
        }

        //public global::Utubz.Internal.Native.Bass.TAG_CUE_POINT[] CuePoints
        //{
        //    get
        //    {
        //        return ((__Internal*)__Instance)->CuePoints;
        //    }

        //    set
        //    {
        //        global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal[] __value;
        //        if (value is null)
        //            __value = null;
        //        else
        //        {
        //            __value = new global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal[value.Length];
        //            for (int i = 0; i < __value.Length; i++)
        //            {
        //                var __element = value[i];
        //                __value[i] = __element is null ? new global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal() : *(global::Utubz.Internal.Native.Bass.TAG_CUE_POINT.__Internal*)__element.__Instance;
        //            }
        //        }
        //        ((__Internal*)__Instance)->CuePoints = __value;
        //    }
        //}
    }

    internal unsafe partial class TAG_SMPL_LOOP : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint dwIdentifier;
            internal uint dwType;
            internal uint dwStart;
            internal uint dwEnd;
            internal uint dwFraction;
            internal uint dwPlayCount;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_SMPL_LOOP@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP>();

        protected bool __ownsNativeInstance;

        internal static TAG_SMPL_LOOP __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_SMPL_LOOP(native.ToPointer(), skipVTables);
        }

        internal static TAG_SMPL_LOOP __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_SMPL_LOOP)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_SMPL_LOOP __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_SMPL_LOOP(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_SMPL_LOOP(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_SMPL_LOOP(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_SMPL_LOOP()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_SMPL_LOOP(global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwIdentifier
        {
            get
            {
                return ((__Internal*)__Instance)->dwIdentifier;
            }

            set
            {
                ((__Internal*)__Instance)->dwIdentifier = value;
            }
        }

        public uint DwType
        {
            get
            {
                return ((__Internal*)__Instance)->dwType;
            }

            set
            {
                ((__Internal*)__Instance)->dwType = value;
            }
        }

        public uint DwStart
        {
            get
            {
                return ((__Internal*)__Instance)->dwStart;
            }

            set
            {
                ((__Internal*)__Instance)->dwStart = value;
            }
        }

        public uint DwEnd
        {
            get
            {
                return ((__Internal*)__Instance)->dwEnd;
            }

            set
            {
                ((__Internal*)__Instance)->dwEnd = value;
            }
        }

        public uint DwFraction
        {
            get
            {
                return ((__Internal*)__Instance)->dwFraction;
            }

            set
            {
                ((__Internal*)__Instance)->dwFraction = value;
            }
        }

        public uint DwPlayCount
        {
            get
            {
                return ((__Internal*)__Instance)->dwPlayCount;
            }

            set
            {
                ((__Internal*)__Instance)->dwPlayCount = value;
            }
        }
    }

    internal unsafe partial class TAG_SMPL : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            internal uint dwManufacturer;
            internal uint dwProduct;
            internal uint dwSamplePeriod;
            internal uint dwMIDIUnityNote;
            internal uint dwMIDIPitchFraction;
            internal uint dwSMPTEFormat;
            internal uint dwSMPTEOffset;
            internal uint cSampleLoops;
            internal uint cbSamplerData;
            internal __IntPtr SampleLoops;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_SMPL@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_SMPL> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_SMPL>();

        protected bool __ownsNativeInstance;

        internal static TAG_SMPL __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_SMPL(native.ToPointer(), skipVTables);
        }

        internal static TAG_SMPL __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_SMPL)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_SMPL __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_SMPL(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_SMPL(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_SMPL(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_SMPL()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_SMPL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_SMPL(global::Utubz.Internal.Native.Bass.TAG_SMPL __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_SMPL.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_SMPL.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_SMPL.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwManufacturer
        {
            get
            {
                return ((__Internal*)__Instance)->dwManufacturer;
            }

            set
            {
                ((__Internal*)__Instance)->dwManufacturer = value;
            }
        }

        public uint DwProduct
        {
            get
            {
                return ((__Internal*)__Instance)->dwProduct;
            }

            set
            {
                ((__Internal*)__Instance)->dwProduct = value;
            }
        }

        public uint DwSamplePeriod
        {
            get
            {
                return ((__Internal*)__Instance)->dwSamplePeriod;
            }

            set
            {
                ((__Internal*)__Instance)->dwSamplePeriod = value;
            }
        }

        public uint DwMIDIUnityNote
        {
            get
            {
                return ((__Internal*)__Instance)->dwMIDIUnityNote;
            }

            set
            {
                ((__Internal*)__Instance)->dwMIDIUnityNote = value;
            }
        }

        public uint DwMIDIPitchFraction
        {
            get
            {
                return ((__Internal*)__Instance)->dwMIDIPitchFraction;
            }

            set
            {
                ((__Internal*)__Instance)->dwMIDIPitchFraction = value;
            }
        }

        public uint DwSMPTEFormat
        {
            get
            {
                return ((__Internal*)__Instance)->dwSMPTEFormat;
            }

            set
            {
                ((__Internal*)__Instance)->dwSMPTEFormat = value;
            }
        }

        public uint DwSMPTEOffset
        {
            get
            {
                return ((__Internal*)__Instance)->dwSMPTEOffset;
            }

            set
            {
                ((__Internal*)__Instance)->dwSMPTEOffset = value;
            }
        }

        public uint CSampleLoops
        {
            get
            {
                return ((__Internal*)__Instance)->cSampleLoops;
            }

            set
            {
                ((__Internal*)__Instance)->cSampleLoops = value;
            }
        }

        public uint CbSamplerData
        {
            get
            {
                return ((__Internal*)__Instance)->cbSamplerData;
            }

            set
            {
                ((__Internal*)__Instance)->cbSamplerData = value;
            }
        }

        //public global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP[] SampleLoops
        //{
        //    get
        //    {
        //        return Utubz.Internal.Native.MarshalUtil.GetArray<TAG_SMPL_LOOP.__Internal>((void*)((__Internal*)__Instance)->SampleLoops, 0);
        //    }

        //    set
        //    {
        //        global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal[] __value;
        //        if (value is null)
        //            __value = null;
        //        else
        //        {
        //            __value = new global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal[value.Length];
        //            for (int i = 0; i < __value.Length; i++)
        //            {
        //                var __element = value[i];
        //                __value[i] = __element is null ? new global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal() : *(global::Utubz.Internal.Native.Bass.TAG_SMPL_LOOP.__Internal*)__element.__Instance;
        //            }
        //        }
        //        ((__Internal*)__Instance)->SampleLoops = __value;
        //    }
        //}
    }

    internal unsafe partial class TAG_CA_CODEC : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint ftype;
            internal uint atype;
            internal __IntPtr name;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0TAG_CA_CODEC@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CA_CODEC> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.TAG_CA_CODEC>();

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static TAG_CA_CODEC __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new TAG_CA_CODEC(native.ToPointer(), skipVTables);
        }

        internal static TAG_CA_CODEC __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (TAG_CA_CODEC)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static TAG_CA_CODEC __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TAG_CA_CODEC(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private TAG_CA_CODEC(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TAG_CA_CODEC(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TAG_CA_CODEC()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CA_CODEC.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TAG_CA_CODEC(global::Utubz.Internal.Native.Bass.TAG_CA_CODEC __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.TAG_CA_CODEC.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.TAG_CA_CODEC.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.TAG_CA_CODEC.__Internal*)__0.__Instance);
            if (__0.__name_OwnsNativeMemory)
                this.Name = __0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Ftype
        {
            get
            {
                return ((__Internal*)__Instance)->ftype;
            }

            set
            {
                ((__Internal*)__Instance)->ftype = value;
            }
        }

        public uint Atype
        {
            get
            {
                return ((__Internal*)__Instance)->atype;
            }

            set
            {
                ((__Internal*)__Instance)->atype = value;
            }
        }

        public string Name
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr)__bytePtr0;
            }
        }
    }

    internal unsafe partial class BASS_DX8CHORUS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fWetDryMix;
            internal float fDepth;
            internal float fFeedback;
            internal float fFrequency;
            internal uint lWaveform;
            internal float fDelay;
            internal uint lPhase;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_CHORUS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8CHORUS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8CHORUS(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8CHORUS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8CHORUS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8CHORUS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8CHORUS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8CHORUS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8CHORUS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8CHORUS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8CHORUS(global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8CHORUS.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FWetDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetDryMix = value;
            }
        }

        public float FDepth
        {
            get
            {
                return ((__Internal*)__Instance)->fDepth;
            }

            set
            {
                ((__Internal*)__Instance)->fDepth = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FFrequency
        {
            get
            {
                return ((__Internal*)__Instance)->fFrequency;
            }

            set
            {
                ((__Internal*)__Instance)->fFrequency = value;
            }
        }

        public uint LWaveform
        {
            get
            {
                return ((__Internal*)__Instance)->lWaveform;
            }

            set
            {
                ((__Internal*)__Instance)->lWaveform = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public uint LPhase
        {
            get
            {
                return ((__Internal*)__Instance)->lPhase;
            }

            set
            {
                ((__Internal*)__Instance)->lPhase = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8COMPRESSOR : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float fGain;
            internal float fAttack;
            internal float fRelease;
            internal float fThreshold;
            internal float fRatio;
            internal float fPredelay;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_COMPRESSOR@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8COMPRESSOR __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8COMPRESSOR(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8COMPRESSOR __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8COMPRESSOR)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8COMPRESSOR __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8COMPRESSOR(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8COMPRESSOR(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8COMPRESSOR(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8COMPRESSOR()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8COMPRESSOR(global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8COMPRESSOR.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FAttack
        {
            get
            {
                return ((__Internal*)__Instance)->fAttack;
            }

            set
            {
                ((__Internal*)__Instance)->fAttack = value;
            }
        }

        public float FRelease
        {
            get
            {
                return ((__Internal*)__Instance)->fRelease;
            }

            set
            {
                ((__Internal*)__Instance)->fRelease = value;
            }
        }

        public float FThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->fThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->fThreshold = value;
            }
        }

        public float FRatio
        {
            get
            {
                return ((__Internal*)__Instance)->fRatio;
            }

            set
            {
                ((__Internal*)__Instance)->fRatio = value;
            }
        }

        public float FPredelay
        {
            get
            {
                return ((__Internal*)__Instance)->fPredelay;
            }

            set
            {
                ((__Internal*)__Instance)->fPredelay = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8DISTORTION : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal float fGain;
            internal float fEdge;
            internal float fPostEQCenterFrequency;
            internal float fPostEQBandwidth;
            internal float fPreLowpassCutoff;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_DISTORTION@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8DISTORTION __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8DISTORTION(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8DISTORTION __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8DISTORTION)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8DISTORTION __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8DISTORTION(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8DISTORTION(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8DISTORTION(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8DISTORTION()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8DISTORTION(global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8DISTORTION.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FEdge
        {
            get
            {
                return ((__Internal*)__Instance)->fEdge;
            }

            set
            {
                ((__Internal*)__Instance)->fEdge = value;
            }
        }

        public float FPostEQCenterFrequency
        {
            get
            {
                return ((__Internal*)__Instance)->fPostEQCenterFrequency;
            }

            set
            {
                ((__Internal*)__Instance)->fPostEQCenterFrequency = value;
            }
        }

        public float FPostEQBandwidth
        {
            get
            {
                return ((__Internal*)__Instance)->fPostEQBandwidth;
            }

            set
            {
                ((__Internal*)__Instance)->fPostEQBandwidth = value;
            }
        }

        public float FPreLowpassCutoff
        {
            get
            {
                return ((__Internal*)__Instance)->fPreLowpassCutoff;
            }

            set
            {
                ((__Internal*)__Instance)->fPreLowpassCutoff = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8ECHO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal float fWetDryMix;
            internal float fFeedback;
            internal float fLeftDelay;
            internal float fRightDelay;
            internal int lPanDelay;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_ECHO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8ECHO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8ECHO>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8ECHO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8ECHO(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8ECHO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8ECHO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8ECHO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8ECHO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8ECHO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8ECHO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8ECHO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8ECHO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8ECHO(global::Utubz.Internal.Native.Bass.BASS_DX8ECHO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8ECHO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8ECHO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8ECHO.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FWetDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetDryMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FLeftDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fLeftDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fLeftDelay = value;
            }
        }

        public float FRightDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fRightDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fRightDelay = value;
            }
        }

        public int LPanDelay
        {
            get
            {
                return ((__Internal*)__Instance)->lPanDelay;
            }

            set
            {
                ((__Internal*)__Instance)->lPanDelay = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8FLANGER : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fWetDryMix;
            internal float fDepth;
            internal float fFeedback;
            internal float fFrequency;
            internal uint lWaveform;
            internal float fDelay;
            internal uint lPhase;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_FLANGER@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8FLANGER __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8FLANGER(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8FLANGER __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8FLANGER)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8FLANGER __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8FLANGER(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8FLANGER(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8FLANGER(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8FLANGER()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8FLANGER(global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8FLANGER.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FWetDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetDryMix = value;
            }
        }

        public float FDepth
        {
            get
            {
                return ((__Internal*)__Instance)->fDepth;
            }

            set
            {
                ((__Internal*)__Instance)->fDepth = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FFrequency
        {
            get
            {
                return ((__Internal*)__Instance)->fFrequency;
            }

            set
            {
                ((__Internal*)__Instance)->fFrequency = value;
            }
        }

        public uint LWaveform
        {
            get
            {
                return ((__Internal*)__Instance)->lWaveform;
            }

            set
            {
                ((__Internal*)__Instance)->lWaveform = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public uint LPhase
        {
            get
            {
                return ((__Internal*)__Instance)->lPhase;
            }

            set
            {
                ((__Internal*)__Instance)->lPhase = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8GARGLE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint dwRateHz;
            internal uint dwWaveShape;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_GARGLE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8GARGLE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8GARGLE(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8GARGLE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8GARGLE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8GARGLE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8GARGLE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8GARGLE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8GARGLE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8GARGLE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8GARGLE(global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8GARGLE.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint DwRateHz
        {
            get
            {
                return ((__Internal*)__Instance)->dwRateHz;
            }

            set
            {
                ((__Internal*)__Instance)->dwRateHz = value;
            }
        }

        public uint DwWaveShape
        {
            get
            {
                return ((__Internal*)__Instance)->dwWaveShape;
            }

            set
            {
                ((__Internal*)__Instance)->dwWaveShape = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8I3DL2REVERB : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal int lRoom;
            internal int lRoomHF;
            internal float flRoomRolloffFactor;
            internal float flDecayTime;
            internal float flDecayHFRatio;
            internal int lReflections;
            internal float flReflectionsDelay;
            internal int lReverb;
            internal float flReverbDelay;
            internal float flDiffusion;
            internal float flDensity;
            internal float flHFReference;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_I3DL2REVERB@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8I3DL2REVERB __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8I3DL2REVERB(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8I3DL2REVERB __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8I3DL2REVERB)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8I3DL2REVERB __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8I3DL2REVERB(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8I3DL2REVERB(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8I3DL2REVERB(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8I3DL2REVERB()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8I3DL2REVERB(global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8I3DL2REVERB.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LRoom
        {
            get
            {
                return ((__Internal*)__Instance)->lRoom;
            }

            set
            {
                ((__Internal*)__Instance)->lRoom = value;
            }
        }

        public int LRoomHF
        {
            get
            {
                return ((__Internal*)__Instance)->lRoomHF;
            }

            set
            {
                ((__Internal*)__Instance)->lRoomHF = value;
            }
        }

        public float FlRoomRolloffFactor
        {
            get
            {
                return ((__Internal*)__Instance)->flRoomRolloffFactor;
            }

            set
            {
                ((__Internal*)__Instance)->flRoomRolloffFactor = value;
            }
        }

        public float FlDecayTime
        {
            get
            {
                return ((__Internal*)__Instance)->flDecayTime;
            }

            set
            {
                ((__Internal*)__Instance)->flDecayTime = value;
            }
        }

        public float FlDecayHFRatio
        {
            get
            {
                return ((__Internal*)__Instance)->flDecayHFRatio;
            }

            set
            {
                ((__Internal*)__Instance)->flDecayHFRatio = value;
            }
        }

        public int LReflections
        {
            get
            {
                return ((__Internal*)__Instance)->lReflections;
            }

            set
            {
                ((__Internal*)__Instance)->lReflections = value;
            }
        }

        public float FlReflectionsDelay
        {
            get
            {
                return ((__Internal*)__Instance)->flReflectionsDelay;
            }

            set
            {
                ((__Internal*)__Instance)->flReflectionsDelay = value;
            }
        }

        public int LReverb
        {
            get
            {
                return ((__Internal*)__Instance)->lReverb;
            }

            set
            {
                ((__Internal*)__Instance)->lReverb = value;
            }
        }

        public float FlReverbDelay
        {
            get
            {
                return ((__Internal*)__Instance)->flReverbDelay;
            }

            set
            {
                ((__Internal*)__Instance)->flReverbDelay = value;
            }
        }

        public float FlDiffusion
        {
            get
            {
                return ((__Internal*)__Instance)->flDiffusion;
            }

            set
            {
                ((__Internal*)__Instance)->flDiffusion = value;
            }
        }

        public float FlDensity
        {
            get
            {
                return ((__Internal*)__Instance)->flDensity;
            }

            set
            {
                ((__Internal*)__Instance)->flDensity = value;
            }
        }

        public float FlHFReference
        {
            get
            {
                return ((__Internal*)__Instance)->flHFReference;
            }

            set
            {
                ((__Internal*)__Instance)->flHFReference = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8PARAMEQ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float fCenter;
            internal float fBandwidth;
            internal float fGain;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_PARAMEQ@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8PARAMEQ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8PARAMEQ(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8PARAMEQ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8PARAMEQ)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8PARAMEQ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8PARAMEQ(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8PARAMEQ(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8PARAMEQ(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8PARAMEQ()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8PARAMEQ(global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8PARAMEQ.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FCenter
        {
            get
            {
                return ((__Internal*)__Instance)->fCenter;
            }

            set
            {
                ((__Internal*)__Instance)->fCenter = value;
            }
        }

        public float FBandwidth
        {
            get
            {
                return ((__Internal*)__Instance)->fBandwidth;
            }

            set
            {
                ((__Internal*)__Instance)->fBandwidth = value;
            }
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }
    }

    internal unsafe partial class BASS_DX8REVERB : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float fInGain;
            internal float fReverbMix;
            internal float fReverbTime;
            internal float fHighFreqRTRatio;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_DX8_REVERB@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8REVERB> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_DX8REVERB>();

        protected bool __ownsNativeInstance;

        internal static BASS_DX8REVERB __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_DX8REVERB(native.ToPointer(), skipVTables);
        }

        internal static BASS_DX8REVERB __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_DX8REVERB)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_DX8REVERB __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_DX8REVERB(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_DX8REVERB(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_DX8REVERB(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_DX8REVERB()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_DX8REVERB(global::Utubz.Internal.Native.Bass.BASS_DX8REVERB __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_DX8REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_DX8REVERB.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_DX8REVERB.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FInGain
        {
            get
            {
                return ((__Internal*)__Instance)->fInGain;
            }

            set
            {
                ((__Internal*)__Instance)->fInGain = value;
            }
        }

        public float FReverbMix
        {
            get
            {
                return ((__Internal*)__Instance)->fReverbMix;
            }

            set
            {
                ((__Internal*)__Instance)->fReverbMix = value;
            }
        }

        public float FReverbTime
        {
            get
            {
                return ((__Internal*)__Instance)->fReverbTime;
            }

            set
            {
                ((__Internal*)__Instance)->fReverbTime = value;
            }
        }

        public float FHighFreqRTRatio
        {
            get
            {
                return ((__Internal*)__Instance)->fHighFreqRTRatio;
            }

            set
            {
                ((__Internal*)__Instance)->fHighFreqRTRatio = value;
            }
        }
    }

    internal unsafe partial class BASS_FX_VOLUME_PARAM : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float fTarget;
            internal float fCurrent;
            internal float fTime;
            internal uint lCurve;

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "??0BASS_FX_VOLUME_PARAM@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM>();

        protected bool __ownsNativeInstance;

        internal static BASS_FX_VOLUME_PARAM __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_FX_VOLUME_PARAM(native.ToPointer(), skipVTables);
        }

        internal static BASS_FX_VOLUME_PARAM __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_FX_VOLUME_PARAM)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_FX_VOLUME_PARAM __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_FX_VOLUME_PARAM(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_FX_VOLUME_PARAM(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_FX_VOLUME_PARAM(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_FX_VOLUME_PARAM()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_FX_VOLUME_PARAM(global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_FX_VOLUME_PARAM.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FTarget
        {
            get
            {
                return ((__Internal*)__Instance)->fTarget;
            }

            set
            {
                ((__Internal*)__Instance)->fTarget = value;
            }
        }

        public float FCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->fCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->fCurrent = value;
            }
        }

        public float FTime
        {
            get
            {
                return ((__Internal*)__Instance)->fTime;
            }

            set
            {
                ((__Internal*)__Instance)->fTime = value;
            }
        }

        public uint LCurve
        {
            get
            {
                return ((__Internal*)__Instance)->lCurve;
            }

            set
            {
                ((__Internal*)__Instance)->lCurve = value;
            }
        }
    }

    internal unsafe partial class bass
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SetConfig(uint option, uint value);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_GetConfig(uint option);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SetConfigPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SetConfigPtr(uint option, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetConfigPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr BASS_GetConfigPtr(uint option);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_GetVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ErrorGetCode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ErrorGetCode();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetDeviceInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_GetDeviceInfo(uint device, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Free();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SetDevice(uint device);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_GetDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_GetInfo(__IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Start();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Stop();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Pause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Pause();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_IsStarted", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_IsStarted();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Init(int device, uint freq, uint flags, __IntPtr win, __IntPtr dsguid);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Update", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Update(uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetCPU", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float BASS_GetCPU();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SetVolume", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SetVolume(float volume);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetVolume", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float BASS_GetVolume();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_GetDSoundObject", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr BASS_GetDSoundObject(uint @object);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Set3DFactors", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Set3DFactors(float distf, float rollf, float doppf);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Get3DFactors", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Get3DFactors(float* distf, float* rollf, float* doppf);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Set3DPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Set3DPosition(__IntPtr pos, __IntPtr vel, __IntPtr front, __IntPtr top);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Get3DPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_Get3DPosition(__IntPtr pos, __IntPtr vel, __IntPtr front, __IntPtr top);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_Apply3D", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void BASS_Apply3D();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_PluginFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_PluginFree(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_PluginEnable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_PluginEnable(uint handle, int enable);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_PluginGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr BASS_PluginGetInfo(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleLoad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_SampleLoad(int mem, __IntPtr file, ulong offset, uint length, uint max, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleCreate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_SampleCreate(uint length, uint freq, uint chans, uint max, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleFree(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleSetData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleSetData(uint handle, __IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleGetData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleGetData(uint handle, __IntPtr buffer);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleGetInfo(uint handle, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleSetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleSetInfo(uint handle, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleGetChannel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_SampleGetChannel(uint handle, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleGetChannels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_SampleGetChannels(uint handle, uint* channels);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SampleStop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SampleStop(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamCreate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamCreate(uint freq, uint chans, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamCreateFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamCreateFile(int mem, __IntPtr file, ulong offset, ulong length, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamCreateFileUser", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamCreateFileUser(uint system, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_StreamFree(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamGetFilePosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong BASS_StreamGetFilePosition(uint handle, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamPutData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamPutData(uint handle, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamPutFileData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamPutFileData(uint handle, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_MusicLoad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_MusicLoad(int mem, __IntPtr file, ulong offset, uint length, uint flags, uint freq);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_MusicFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_MusicFree(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordGetDeviceInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordGetDeviceInfo(uint device, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordInit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordInit(int device);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordFree();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordSetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordSetDevice(uint device);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordGetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_RecordGetDevice();

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordGetInfo(__IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordGetInputName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr BASS_RecordGetInputName(int input);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordSetInput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_RecordSetInput(int input, uint flags, float volume);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordGetInput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_RecordGetInput(int input, float* volume);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_RecordStart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_RecordStart(uint freq, uint chans, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelBytes2Seconds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double BASS_ChannelBytes2Seconds(uint handle, ulong pos);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSeconds2Bytes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong BASS_ChannelSeconds2Bytes(uint handle, double pos);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelGetDevice(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSetDevice(uint handle, uint device);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelIsActive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelIsActive(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelGetInfo(uint handle, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetTags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr BASS_ChannelGetTags(uint handle, uint tags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelFlags(uint handle, uint flags, uint mask);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelLock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelLock(uint handle, int @lock);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelFree(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelPlay", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelPlay(uint handle, int restart);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelStop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelStop(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelPause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelPause(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelUpdate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelUpdate(uint handle, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSetAttribute(uint handle, uint attrib, float value);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelGetAttribute(uint handle, uint attrib, float* value);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSlideAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSlideAttribute(uint handle, uint attrib, float value, uint time);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelIsSliding", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelIsSliding(uint handle, uint attrib);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetAttributeEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSetAttributeEx(uint handle, uint attrib, __IntPtr value, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetAttributeEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelGetAttributeEx(uint handle, uint attrib, __IntPtr value, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSet3DAttributes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSet3DAttributes(uint handle, int mode, float min, float max, int iangle, int oangle, float outvol);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGet3DAttributes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelGet3DAttributes(uint handle, uint* mode, float* min, float* max, uint* iangle, uint* oangle, float* outvol);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSet3DPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSet3DPosition(uint handle, __IntPtr pos, __IntPtr orient, __IntPtr vel);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGet3DPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelGet3DPosition(uint handle, __IntPtr pos, __IntPtr orient, __IntPtr vel);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetLength", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong BASS_ChannelGetLength(uint handle, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSetPosition(uint handle, ulong pos, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong BASS_ChannelGetPosition(uint handle, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelGetLevel(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetLevelEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelGetLevelEx(uint handle, float* levels, float length, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelGetData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelGetData(uint handle, __IntPtr buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetSync", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelSetSync(uint handle, uint type, ulong param, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelRemoveSync", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelRemoveSync(uint handle, uint sync);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetLink", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelSetLink(uint handle, uint chan);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelRemoveLink", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelRemoveLink(uint handle, uint chan);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetDSP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelSetDSP(uint handle, __IntPtr proc, __IntPtr user, int priority);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelRemoveDSP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelRemoveDSP(uint handle, uint dsp);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelSetFX", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_ChannelSetFX(uint handle, uint type, int priority);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_ChannelRemoveFX", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_ChannelRemoveFX(uint handle, uint fx);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_FXSetParameters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FXSetParameters(uint handle, __IntPtr @params);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_FXGetParameters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FXGetParameters(uint handle, __IntPtr @params);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_FXSetPriority", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FXSetPriority(uint handle, int priority);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_FXReset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FXReset(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "?BASS_PluginLoad@@YAKPEB_WK@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_PluginLoad([MarshalAs(UnmanagedType.LPWStr)] string file, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "?BASS_MusicLoad@@YAKHPEB_W_KKKK@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_MusicLoad(int mem, [MarshalAs(UnmanagedType.LPUTF8Str)] string file, ulong offset, uint length, uint flags, uint freq);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "?BASS_SampleLoad@@YAKHPEB_W_KKKK@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_SampleLoad(int mem, [MarshalAs(UnmanagedType.LPUTF8Str)] string file, ulong offset, uint length, uint max, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamCreateFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamCreateFile(int mem, [MarshalAs(UnmanagedType.LPUTF8Str)] string file, ulong offset, ulong length, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_StreamCreateURL", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_StreamCreateURL([MarshalAs(UnmanagedType.LPUTF8Str)] string url, uint offset, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("Bass", EntryPoint = "BASS_SetConfigPtr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_SetConfigPtr(uint option, [MarshalAs(UnmanagedType.LPUTF8Str)] string value);
        }

        public static int BASS_SetConfig(uint option, uint value)
        {
            var __ret = __Internal.BASS_SetConfig(option, value);
            return __ret;
        }

        public static uint BASS_GetConfig(uint option)
        {
            var __ret = __Internal.BASS_GetConfig(option);
            return __ret;
        }

        public static int BASS_SetConfigPtr(uint option, __IntPtr value)
        {
            var __ret = __Internal.BASS_SetConfigPtr(option, value);
            return __ret;
        }

        public static __IntPtr BASS_GetConfigPtr(uint option)
        {
            var __ret = __Internal.BASS_GetConfigPtr(option);
            return __ret;
        }

        public static uint BASS_GetVersion()
        {
            var __ret = __Internal.BASS_GetVersion();
            return __ret;
        }

        public static int BASS_ErrorGetCode()
        {
            var __ret = __Internal.BASS_ErrorGetCode();
            return __ret;
        }

        public static int BASS_GetDeviceInfo(uint device, global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_GetDeviceInfo(device, __arg1);
            return __ret;
        }

        public static int BASS_Free()
        {
            var __ret = __Internal.BASS_Free();
            return __ret;
        }

        public static int BASS_SetDevice(uint device)
        {
            var __ret = __Internal.BASS_SetDevice(device);
            return __ret;
        }

        public static uint BASS_GetDevice()
        {
            var __ret = __Internal.BASS_GetDevice();
            return __ret;
        }

        public static int BASS_GetInfo(global::Utubz.Internal.Native.Bass.BASS_INFO info)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_GetInfo(__arg0);
            return __ret;
        }

        public static int BASS_Start()
        {
            var __ret = __Internal.BASS_Start();
            return __ret;
        }

        public static int BASS_Stop()
        {
            var __ret = __Internal.BASS_Stop();
            return __ret;
        }

        public static int BASS_Pause()
        {
            var __ret = __Internal.BASS_Pause();
            return __ret;
        }

        public static uint BASS_IsStarted()
        {
            var __ret = __Internal.BASS_IsStarted();
            return __ret;
        }

        public static int BASS_Init(int device, uint freq, uint flags, __IntPtr win, __IntPtr dsguid)
        {
            var __ret = __Internal.BASS_Init(device, freq, flags, win, dsguid);
            return __ret;
        }

        public static int BASS_Update(uint length)
        {
            var __ret = __Internal.BASS_Update(length);
            return __ret;
        }

        public static float BASS_GetCPU()
        {
            var __ret = __Internal.BASS_GetCPU();
            return __ret;
        }

        public static int BASS_SetVolume(float volume)
        {
            var __ret = __Internal.BASS_SetVolume(volume);
            return __ret;
        }

        public static float BASS_GetVolume()
        {
            var __ret = __Internal.BASS_GetVolume();
            return __ret;
        }

        public static __IntPtr BASS_GetDSoundObject(uint @object)
        {
            var __ret = __Internal.BASS_GetDSoundObject(@object);
            return __ret;
        }

        public static int BASS_Set3DFactors(float distf, float rollf, float doppf)
        {
            var __ret = __Internal.BASS_Set3DFactors(distf, rollf, doppf);
            return __ret;
        }

        public static int BASS_Get3DFactors(ref float distf, ref float rollf, ref float doppf)
        {
            fixed (float* __distf0 = &distf)
            {
                var __arg0 = __distf0;
                fixed (float* __rollf1 = &rollf)
                {
                    var __arg1 = __rollf1;
                    fixed (float* __doppf2 = &doppf)
                    {
                        var __arg2 = __doppf2;
                        var __ret = __Internal.BASS_Get3DFactors(__arg0, __arg1, __arg2);
                        return __ret;
                    }
                }
            }
        }

        public static int BASS_Set3DPosition(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR pos, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR vel, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR front, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR top)
        {
            var __arg0 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var __arg1 = vel is null ? __IntPtr.Zero : vel.__Instance;
            var __arg2 = front is null ? __IntPtr.Zero : front.__Instance;
            var __arg3 = top is null ? __IntPtr.Zero : top.__Instance;
            var __ret = __Internal.BASS_Set3DPosition(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        public static int BASS_Get3DPosition(global::Utubz.Internal.Native.Bass.BASS_3DVECTOR pos, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR vel, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR front, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR top)
        {
            var __arg0 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var __arg1 = vel is null ? __IntPtr.Zero : vel.__Instance;
            var __arg2 = front is null ? __IntPtr.Zero : front.__Instance;
            var __arg3 = top is null ? __IntPtr.Zero : top.__Instance;
            var __ret = __Internal.BASS_Get3DPosition(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }

        public static void BASS_Apply3D()
        {
            __Internal.BASS_Apply3D();
        }

        public static int BASS_PluginFree(uint handle)
        {
            var __ret = __Internal.BASS_PluginFree(handle);
            return __ret;
        }

        public static int BASS_PluginEnable(uint handle, int enable)
        {
            var __ret = __Internal.BASS_PluginEnable(handle, enable);
            return __ret;
        }

        public static global::Utubz.Internal.Native.Bass.BASS_PLUGININFO BASS_PluginGetInfo(uint handle)
        {
            var __ret = __Internal.BASS_PluginGetInfo(handle);
            var __result0 = global::Utubz.Internal.Native.Bass.BASS_PLUGININFO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static uint BASS_SampleLoad(int mem, __IntPtr file, ulong offset, uint length, uint max, uint flags)
        {
            var __ret = __Internal.BASS_SampleLoad(mem, file, offset, length, max, flags);
            return __ret;
        }

        public static uint BASS_SampleCreate(uint length, uint freq, uint chans, uint max, uint flags)
        {
            var __ret = __Internal.BASS_SampleCreate(length, freq, chans, max, flags);
            return __ret;
        }

        public static int BASS_SampleFree(uint handle)
        {
            var __ret = __Internal.BASS_SampleFree(handle);
            return __ret;
        }

        public static int BASS_SampleSetData(uint handle, __IntPtr buffer)
        {
            var __ret = __Internal.BASS_SampleSetData(handle, buffer);
            return __ret;
        }

        public static int BASS_SampleGetData(uint handle, __IntPtr buffer)
        {
            var __ret = __Internal.BASS_SampleGetData(handle, buffer);
            return __ret;
        }

        public static int BASS_SampleGetInfo(uint handle, global::Utubz.Internal.Native.Bass.BASS_SAMPLE info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_SampleGetInfo(handle, __arg1);
            return __ret;
        }

        public static int BASS_SampleSetInfo(uint handle, global::Utubz.Internal.Native.Bass.BASS_SAMPLE info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_SampleSetInfo(handle, __arg1);
            return __ret;
        }

        public static uint BASS_SampleGetChannel(uint handle, uint flags)
        {
            var __ret = __Internal.BASS_SampleGetChannel(handle, flags);
            return __ret;
        }

        public static uint BASS_SampleGetChannels(uint handle, ref uint channels)
        {
            fixed (uint* __channels1 = &channels)
            {
                var __arg1 = __channels1;
                var __ret = __Internal.BASS_SampleGetChannels(handle, __arg1);
                return __ret;
            }
        }

        public static int BASS_SampleStop(uint handle)
        {
            var __ret = __Internal.BASS_SampleStop(handle);
            return __ret;
        }

        public static uint BASS_StreamCreate(uint freq, uint chans, uint flags, __IntPtr proc, __IntPtr user)
        {
            var __arg3 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_StreamCreate(freq, chans, flags, __arg3, user);
            return __ret;
        }

        public static uint BASS_StreamCreateFile(int mem, __IntPtr file, ulong offset, ulong length, uint flags)
        {
            var __ret = __Internal.BASS_StreamCreateFile(mem, file, offset, length, flags);
            return __ret;
        }

        public static uint BASS_StreamCreateFileUser(uint system, uint flags, global::Utubz.Internal.Native.Bass.BASS_FILEPROCS proc, __IntPtr user)
        {
            var __arg2 = proc is null ? __IntPtr.Zero : proc.__Instance;
            var __ret = __Internal.BASS_StreamCreateFileUser(system, flags, __arg2, user);
            return __ret;
        }

        public static int BASS_StreamFree(uint handle)
        {
            var __ret = __Internal.BASS_StreamFree(handle);
            return __ret;
        }

        public static ulong BASS_StreamGetFilePosition(uint handle, uint mode)
        {
            var __ret = __Internal.BASS_StreamGetFilePosition(handle, mode);
            return __ret;
        }

        public static uint BASS_StreamPutData(uint handle, __IntPtr buffer, uint length)
        {
            var __ret = __Internal.BASS_StreamPutData(handle, buffer, length);
            return __ret;
        }

        public static uint BASS_StreamPutFileData(uint handle, __IntPtr buffer, uint length)
        {
            var __ret = __Internal.BASS_StreamPutFileData(handle, buffer, length);
            return __ret;
        }

        public static uint BASS_MusicLoad(int mem, __IntPtr file, ulong offset, uint length, uint flags, uint freq)
        {
            var __ret = __Internal.BASS_MusicLoad(mem, file, offset, length, flags, freq);
            return __ret;
        }

        public static int BASS_MusicFree(uint handle)
        {
            var __ret = __Internal.BASS_MusicFree(handle);
            return __ret;
        }

        public static int BASS_RecordGetDeviceInfo(uint device, global::Utubz.Internal.Native.Bass.BASS_DEVICEINFO info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_RecordGetDeviceInfo(device, __arg1);
            return __ret;
        }

        public static int BASS_RecordInit(int device)
        {
            var __ret = __Internal.BASS_RecordInit(device);
            return __ret;
        }

        public static int BASS_RecordFree()
        {
            var __ret = __Internal.BASS_RecordFree();
            return __ret;
        }

        public static int BASS_RecordSetDevice(uint device)
        {
            var __ret = __Internal.BASS_RecordSetDevice(device);
            return __ret;
        }

        public static uint BASS_RecordGetDevice()
        {
            var __ret = __Internal.BASS_RecordGetDevice();
            return __ret;
        }

        public static int BASS_RecordGetInfo(global::Utubz.Internal.Native.Bass.BASS_RECORDINFO info)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_RecordGetInfo(__arg0);
            return __ret;
        }

        public static string BASS_RecordGetInputName(int input)
        {
            var __ret = __Internal.BASS_RecordGetInputName(input);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int BASS_RecordSetInput(int input, uint flags, float volume)
        {
            var __ret = __Internal.BASS_RecordSetInput(input, flags, volume);
            return __ret;
        }

        public static uint BASS_RecordGetInput(int input, ref float volume)
        {
            fixed (float* __volume1 = &volume)
            {
                var __arg1 = __volume1;
                var __ret = __Internal.BASS_RecordGetInput(input, __arg1);
                return __ret;
            }
        }

        public static uint BASS_RecordStart(uint freq, uint chans, uint flags, __IntPtr proc, __IntPtr user)
        {
            var __arg3 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_RecordStart(freq, chans, flags, __arg3, user);
            return __ret;
        }

        public static double BASS_ChannelBytes2Seconds(uint handle, ulong pos)
        {
            var __ret = __Internal.BASS_ChannelBytes2Seconds(handle, pos);
            return __ret;
        }

        public static ulong BASS_ChannelSeconds2Bytes(uint handle, double pos)
        {
            var __ret = __Internal.BASS_ChannelSeconds2Bytes(handle, pos);
            return __ret;
        }

        public static uint BASS_ChannelGetDevice(uint handle)
        {
            var __ret = __Internal.BASS_ChannelGetDevice(handle);
            return __ret;
        }

        public static int BASS_ChannelSetDevice(uint handle, uint device)
        {
            var __ret = __Internal.BASS_ChannelSetDevice(handle, device);
            return __ret;
        }

        public static uint BASS_ChannelIsActive(uint handle)
        {
            var __ret = __Internal.BASS_ChannelIsActive(handle);
            return __ret;
        }

        public static int BASS_ChannelGetInfo(uint handle, global::Utubz.Internal.Native.Bass.BASS_CHANNELINFO info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.BASS_ChannelGetInfo(handle, __arg1);
            return __ret;
        }

        public static string BASS_ChannelGetTags(uint handle, uint tags)
        {
            var __ret = __Internal.BASS_ChannelGetTags(handle, tags);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static uint BASS_ChannelFlags(uint handle, uint flags, uint mask)
        {
            var __ret = __Internal.BASS_ChannelFlags(handle, flags, mask);
            return __ret;
        }

        public static int BASS_ChannelLock(uint handle, int @lock)
        {
            var __ret = __Internal.BASS_ChannelLock(handle, @lock);
            return __ret;
        }

        public static int BASS_ChannelFree(uint handle)
        {
            var __ret = __Internal.BASS_ChannelFree(handle);
            return __ret;
        }

        public static int BASS_ChannelPlay(uint handle, int restart)
        {
            var __ret = __Internal.BASS_ChannelPlay(handle, restart);
            return __ret;
        }

        public static int BASS_ChannelStop(uint handle)
        {
            var __ret = __Internal.BASS_ChannelStop(handle);
            return __ret;
        }

        public static int BASS_ChannelPause(uint handle)
        {
            var __ret = __Internal.BASS_ChannelPause(handle);
            return __ret;
        }

        public static int BASS_ChannelUpdate(uint handle, uint length)
        {
            var __ret = __Internal.BASS_ChannelUpdate(handle, length);
            return __ret;
        }

        public static int BASS_ChannelSetAttribute(uint handle, uint attrib, float value)
        {
            var __ret = __Internal.BASS_ChannelSetAttribute(handle, attrib, value);
            return __ret;
        }

        public static int BASS_ChannelGetAttribute(uint handle, uint attrib, ref float value)
        {
            fixed (float* __value2 = &value)
            {
                var __arg2 = __value2;
                var __ret = __Internal.BASS_ChannelGetAttribute(handle, attrib, __arg2);
                return __ret;
            }
        }

        public static int BASS_ChannelSlideAttribute(uint handle, uint attrib, float value, uint time)
        {
            var __ret = __Internal.BASS_ChannelSlideAttribute(handle, attrib, value, time);
            return __ret;
        }

        public static int BASS_ChannelIsSliding(uint handle, uint attrib)
        {
            var __ret = __Internal.BASS_ChannelIsSliding(handle, attrib);
            return __ret;
        }

        public static int BASS_ChannelSetAttributeEx(uint handle, uint attrib, __IntPtr value, uint size)
        {
            var __ret = __Internal.BASS_ChannelSetAttributeEx(handle, attrib, value, size);
            return __ret;
        }

        public static uint BASS_ChannelGetAttributeEx(uint handle, uint attrib, __IntPtr value, uint size)
        {
            var __ret = __Internal.BASS_ChannelGetAttributeEx(handle, attrib, value, size);
            return __ret;
        }

        public static int BASS_ChannelSet3DAttributes(uint handle, int mode, float min, float max, int iangle, int oangle, float outvol)
        {
            var __ret = __Internal.BASS_ChannelSet3DAttributes(handle, mode, min, max, iangle, oangle, outvol);
            return __ret;
        }

        public static int BASS_ChannelGet3DAttributes(uint handle, ref uint mode, ref float min, ref float max, ref uint iangle, ref uint oangle, ref float outvol)
        {
            fixed (uint* __mode1 = &mode)
            {
                var __arg1 = __mode1;
                fixed (float* __min2 = &min)
                {
                    var __arg2 = __min2;
                    fixed (float* __max3 = &max)
                    {
                        var __arg3 = __max3;
                        fixed (uint* __iangle4 = &iangle)
                        {
                            var __arg4 = __iangle4;
                            fixed (uint* __oangle5 = &oangle)
                            {
                                var __arg5 = __oangle5;
                                fixed (float* __outvol6 = &outvol)
                                {
                                    var __arg6 = __outvol6;
                                    var __ret = __Internal.BASS_ChannelGet3DAttributes(handle, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
                                    return __ret;
                                }
                            }
                        }
                    }
                }
            }
        }

        public static int BASS_ChannelSet3DPosition(uint handle, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR pos, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR orient, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR vel)
        {
            var __arg1 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var __arg2 = orient is null ? __IntPtr.Zero : orient.__Instance;
            var __arg3 = vel is null ? __IntPtr.Zero : vel.__Instance;
            var __ret = __Internal.BASS_ChannelSet3DPosition(handle, __arg1, __arg2, __arg3);
            return __ret;
        }

        public static int BASS_ChannelGet3DPosition(uint handle, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR pos, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR orient, global::Utubz.Internal.Native.Bass.BASS_3DVECTOR vel)
        {
            var __arg1 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var __arg2 = orient is null ? __IntPtr.Zero : orient.__Instance;
            var __arg3 = vel is null ? __IntPtr.Zero : vel.__Instance;
            var __ret = __Internal.BASS_ChannelGet3DPosition(handle, __arg1, __arg2, __arg3);
            return __ret;
        }

        public static ulong BASS_ChannelGetLength(uint handle, uint mode)
        {
            var __ret = __Internal.BASS_ChannelGetLength(handle, mode);
            return __ret;
        }

        public static int BASS_ChannelSetPosition(uint handle, ulong pos, uint mode)
        {
            var __ret = __Internal.BASS_ChannelSetPosition(handle, pos, mode);
            return __ret;
        }

        public static ulong BASS_ChannelGetPosition(uint handle, uint mode)
        {
            var __ret = __Internal.BASS_ChannelGetPosition(handle, mode);
            return __ret;
        }

        public static uint BASS_ChannelGetLevel(uint handle)
        {
            var __ret = __Internal.BASS_ChannelGetLevel(handle);
            return __ret;
        }

        public static int BASS_ChannelGetLevelEx(uint handle, ref float levels, float length, uint flags)
        {
            fixed (float* __levels1 = &levels)
            {
                var __arg1 = __levels1;
                var __ret = __Internal.BASS_ChannelGetLevelEx(handle, __arg1, length, flags);
                return __ret;
            }
        }

        public static uint BASS_ChannelGetData(uint handle, __IntPtr buffer, uint length)
        {
            var __ret = __Internal.BASS_ChannelGetData(handle, buffer, length);
            return __ret;
        }

        public static uint BASS_ChannelSetSync(uint handle, uint type, ulong param, __IntPtr proc, __IntPtr user)
        {
            var __arg3 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_ChannelSetSync(handle, type, param, __arg3, user);
            return __ret;
        }

        public static int BASS_ChannelRemoveSync(uint handle, uint sync)
        {
            var __ret = __Internal.BASS_ChannelRemoveSync(handle, sync);
            return __ret;
        }

        public static int BASS_ChannelSetLink(uint handle, uint chan)
        {
            var __ret = __Internal.BASS_ChannelSetLink(handle, chan);
            return __ret;
        }

        public static int BASS_ChannelRemoveLink(uint handle, uint chan)
        {
            var __ret = __Internal.BASS_ChannelRemoveLink(handle, chan);
            return __ret;
        }

        public static uint BASS_ChannelSetDSP(uint handle, __IntPtr proc, __IntPtr user, int priority)
        {
            var __arg1 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_ChannelSetDSP(handle, __arg1, user, priority);
            return __ret;
        }

        public static int BASS_ChannelRemoveDSP(uint handle, uint dsp)
        {
            var __ret = __Internal.BASS_ChannelRemoveDSP(handle, dsp);
            return __ret;
        }

        public static uint BASS_ChannelSetFX(uint handle, uint type, int priority)
        {
            var __ret = __Internal.BASS_ChannelSetFX(handle, type, priority);
            return __ret;
        }

        public static int BASS_ChannelRemoveFX(uint handle, uint fx)
        {
            var __ret = __Internal.BASS_ChannelRemoveFX(handle, fx);
            return __ret;
        }

        public static int BASS_FXSetParameters(uint handle, __IntPtr @params)
        {
            var __ret = __Internal.BASS_FXSetParameters(handle, @params);
            return __ret;
        }

        public static int BASS_FXGetParameters(uint handle, __IntPtr @params)
        {
            var __ret = __Internal.BASS_FXGetParameters(handle, @params);
            return __ret;
        }

        public static int BASS_FXSetPriority(uint handle, int priority)
        {
            var __ret = __Internal.BASS_FXSetPriority(handle, priority);
            return __ret;
        }

        public static int BASS_FXReset(uint handle)
        {
            var __ret = __Internal.BASS_FXReset(handle);
            return __ret;
        }

        public static uint BASS_PluginLoad(string file, uint flags)
        {
            var __ret = __Internal.BASS_PluginLoad(file, flags);
            return __ret;
        }

        public static uint BASS_MusicLoad(int mem, string file, ulong offset, uint length, uint flags, uint freq)
        {
            var __ret = __Internal.BASS_MusicLoad(mem, file, offset, length, flags, freq);
            return __ret;
        }

        public static uint BASS_SampleLoad(int mem, string file, ulong offset, uint length, uint max, uint flags)
        {
            var __ret = __Internal.BASS_SampleLoad(mem, file, offset, length, max, flags);
            return __ret;
        }

        public static uint BASS_StreamCreateFile(int mem, string file, ulong offset, ulong length, uint flags)
        {
            var __ret = __Internal.BASS_StreamCreateFile(mem, file, offset, length, flags);
            return __ret;
        }

        public static uint BASS_StreamCreateURL(string url, uint offset, uint flags, __IntPtr proc, __IntPtr user)
        {
            var __arg3 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_StreamCreateURL(url, offset, flags, __arg3, user);
            return __ret;
        }

        public static int BASS_SetConfigPtr(uint option, string value)
        {
            var __ret = __Internal.BASS_SetConfigPtr(option, value);
            return __ret;
        }
    }
}
