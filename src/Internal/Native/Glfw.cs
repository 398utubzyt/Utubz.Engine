// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Utubz.Internal.Native.Glfw
{
    /// <summary>Client API function pointer type.</summary>
    /// <remarks>
    /// <para>Generic function pointer used for returning client API function pointers</para>
    /// <para>without forcing a cast from a regular pointer.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWglproc();

    /// <summary>Vulkan API function pointer type.</summary>
    /// <remarks>
    /// <para>Generic function pointer used for returning Vulkan API function pointers</para>
    /// <para>without forcing a cast from a regular pointer.</para>
    /// <para>Added in version 3.2.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWvkproc();

    /// <summary>The function pointer type for error callbacks.</summary>
    /// <param name="error_code">
    /// <para>An [error code](Future releases may add</para>
    /// <para>more error codes.</para>
    /// </param>
    /// <param name="description">A UTF-8 encoded string describing the error.</param>
    /// <remarks>
    /// <para>This is the function pointer type for error callbacks.  An error callback</para>
    /// <para>function has the following signature:</para>
    /// <para>The error description string is valid until the callback</para>
    /// <para>function returns.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWerrorfun(int error_code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string description);

    /// <summary>The function pointer type for window position callbacks.</summary>
    /// <param name="window">The window that was moved.</param>
    /// <param name="xpos">
    /// <para>The new x-coordinate, in screen coordinates, of the</para>
    /// <para>upper-left corner of the content area of the window.</para>
    /// </param>
    /// <param name="ypos">
    /// <para>The new y-coordinate, in screen coordinates, of the</para>
    /// <para>upper-left corner of the content area of the window.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for window position callbacks.  A window</para>
    /// <para>position callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowposfun(__IntPtr window, int xpos, int ypos);

    /// <summary>The function pointer type for window size callbacks.</summary>
    /// <param name="window">The window that was resized.</param>
    /// <param name="width">The new width, in screen coordinates, of the window.</param>
    /// <param name="height">The new height, in screen coordinates, of the window.</param>
    /// <remarks>
    /// <para>This is the function pointer type for window size callbacks.  A window size</para>
    /// <para>callback function has the following signature:</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowsizefun(__IntPtr window, int width, int height);

    /// <summary>The function pointer type for window close callbacks.</summary>
    /// <param name="window">The window that the user attempted to close.</param>
    /// <remarks>
    /// <para>This is the function pointer type for window close callbacks.  A window</para>
    /// <para>close callback function has the following signature:</para>
    /// <para>Added in version 2.5.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowclosefun(__IntPtr window);

    /// <summary>The function pointer type for window content refresh callbacks.</summary>
    /// <param name="window">The window whose content needs to be refreshed.</param>
    /// <remarks>
    /// <para>This is the function pointer type for window content refresh callbacks.</para>
    /// <para>A window content refresh callback function has the following signature:</para>
    /// <para>Added in version 2.5.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowrefreshfun(__IntPtr window);

    /// <summary>The function pointer type for window focus callbacks.</summary>
    /// <param name="window">The window that gained or lost input focus.</param>
    /// <param name="focused">
    /// <para>`GLFW_TRUE` if the window was given input focus, or</para>
    /// <para>`GLFW_FALSE` if it lost it.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for window focus callbacks.  A window</para>
    /// <para>focus callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowfocusfun(__IntPtr window, int focused);

    /// <summary>The function pointer type for window iconify callbacks.</summary>
    /// <param name="window">The window that was iconified or restored.</param>
    /// <param name="iconified">
    /// <para>`GLFW_TRUE` if the window was iconified, or</para>
    /// <para>`GLFW_FALSE` if it was restored.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for window iconify callbacks.  A window</para>
    /// <para>iconify callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowiconifyfun(__IntPtr window, int iconified);

    /// <summary>The function pointer type for window maximize callbacks.</summary>
    /// <param name="window">The window that was maximized or restored.</param>
    /// <param name="maximized">
    /// <para>`GLFW_TRUE` if the window was maximized, or</para>
    /// <para>`GLFW_FALSE` if it was restored.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for window maximize callbacks.  A window</para>
    /// <para>maximize callback function has the following signature:</para>
    /// <para>glfwSetWindowMaximizeCallback</para>
    /// <para>Added in version 3.3.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowmaximizefun(__IntPtr window, int maximized);

    /// <summary>The function pointer type for framebuffer size callbacks.</summary>
    /// <param name="window">The window whose framebuffer was resized.</param>
    /// <param name="width">The new width, in pixels, of the framebuffer.</param>
    /// <param name="height">The new height, in pixels, of the framebuffer.</param>
    /// <remarks>
    /// <para>This is the function pointer type for framebuffer size callbacks.</para>
    /// <para>A framebuffer size callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWframebuffersizefun(__IntPtr window, int width, int height);

    /// <summary>The function pointer type for window content scale callbacks.</summary>
    /// <param name="window">The window whose content scale changed.</param>
    /// <param name="xscale">The new x-axis content scale of the window.</param>
    /// <param name="yscale">The new y-axis content scale of the window.</param>
    /// <remarks>
    /// <para>This is the function pointer type for window content scale callbacks.</para>
    /// <para>A window content scale callback function has the following signature:</para>
    /// <para>Added in version 3.3.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWwindowcontentscalefun(__IntPtr window, float xscale, float yscale);

    /// <summary>The function pointer type for mouse button callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="button">
    /// <para>The [mouse button](that was pressed or</para>
    /// <para>released.</para>
    /// </param>
    /// <param name="action">
    /// <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.  Future releases</para>
    /// <para>may add more actions.</para>
    /// </param>
    /// <param name="mods">
    /// <para>Bit field describing which [modifier keys](were</para>
    /// <para>held down.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for mouse button callback functions.</para>
    /// <para>A mouse button callback function has the following signature:</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle and modifier mask parameters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWmousebuttonfun(__IntPtr window, int button, int action, int mods);

    /// <summary>The function pointer type for cursor position callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xpos">
    /// <para>The new cursor x-coordinate, relative to the left edge of</para>
    /// <para>the content area.</para>
    /// </param>
    /// <param name="ypos">
    /// <para>The new cursor y-coordinate, relative to the top edge of the</para>
    /// <para>content area.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for cursor position callbacks.  A cursor</para>
    /// <para>position callback function has the following signature:</para>
    /// <para>Added in version 3.0.  Replaces `GLFWmouseposfun`.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWcursorposfun(__IntPtr window, double xpos, double ypos);

    /// <summary>The function pointer type for cursor enter/leave callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="entered">
    /// <para>`GLFW_TRUE` if the cursor entered the window's content</para>
    /// <para>area, or `GLFW_FALSE` if it left it.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for cursor enter/leave callbacks.</para>
    /// <para>A cursor enter/leave callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWcursorenterfun(__IntPtr window, int entered);

    /// <summary>The function pointer type for scroll callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xoffset">The scroll offset along the x-axis.</param>
    /// <param name="yoffset">The scroll offset along the y-axis.</param>
    /// <remarks>
    /// <para>This is the function pointer type for scroll callbacks.  A scroll callback</para>
    /// <para>function has the following signature:</para>
    /// <para>Added in version 3.0.  Replaces `GLFWmousewheelfun`.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWscrollfun(__IntPtr window, double xoffset, double yoffset);

    /// <summary>The function pointer type for keyboard key callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="key">The [keyboard key](that was pressed or released.</param>
    /// <param name="scancode">The system-specific scancode of the key.</param>
    /// <param name="action">
    /// <para>`GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future</para>
    /// <para>releases may add more actions.</para>
    /// </param>
    /// <param name="mods">
    /// <para>Bit field describing which [modifier keys](were</para>
    /// <para>held down.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for keyboard key callbacks.  A keyboard</para>
    /// <para>key callback function has the following signature:</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added window handle, scancode and modifier mask parameters.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWkeyfun(__IntPtr window, int key, int scancode, int action, int mods);

    /// <summary>The function pointer type for Unicode character callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <remarks>
    /// <para>This is the function pointer type for Unicode character callbacks.</para>
    /// <para>A Unicode character callback function has the following signature:</para>
    /// <para>Added in version 2.4.</para>
    /// <para>Added window handle parameter.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWcharfun(__IntPtr window, uint codepoint);

    /// <summary>
    /// <para>The function pointer type for Unicode character with modifiers</para>
    /// <para>callbacks.</para>
    /// </summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <param name="mods">
    /// <para>Bit field describing which [modifier keys](were</para>
    /// <para>held down.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for Unicode character with modifiers</para>
    /// <para>callbacks.  It is called for each input character, regardless of what</para>
    /// <para>modifier keys are held down.  A Unicode character with modifiers callback</para>
    /// <para>function has the following signature:</para>
    /// <para>Scheduled for removal in version 4.0.</para>
    /// <para>Added in version 3.1.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWcharmodsfun(__IntPtr window, uint codepoint, int mods);

    /// <summary>The function pointer type for path drop callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="path_count">The number of dropped paths.</param>
    /// <param name="paths">The UTF-8 encoded file and/or directory path names.</param>
    /// <remarks>
    /// <para>This is the function pointer type for path drop callbacks.  A path drop</para>
    /// <para>callback function has the following signature:</para>
    /// <para>The path array and its strings are valid until the</para>
    /// <para>callback function returns.</para>
    /// <para>Added in version 3.1.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWdropfun(__IntPtr window, int path_count, [MarshalAs(UnmanagedType.LPArray)] string[] paths);

    /// <summary>The function pointer type for monitor configuration callbacks.</summary>
    /// <param name="monitor">The monitor that was connected or disconnected.</param>
    /// <param name="event">
    /// <para>One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future</para>
    /// <para>releases may add more events.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for monitor configuration callbacks.</para>
    /// <para>A monitor callback function has the following signature:</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWmonitorfun(__IntPtr monitor, int @event);

    /// <summary>The function pointer type for joystick configuration callbacks.</summary>
    /// <param name="jid">The joystick that was connected or disconnected.</param>
    /// <param name="event">
    /// <para>One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future</para>
    /// <para>releases may add more events.</para>
    /// </param>
    /// <remarks>
    /// <para>This is the function pointer type for joystick configuration callbacks.</para>
    /// <para>A joystick configuration callback function has the following signature:</para>
    /// <para>Added in version 3.2.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    internal unsafe delegate void GLFWjoystickfun(int jid, int @event);

    /// <summary>Video mode type.</summary>
    /// <remarks>
    /// <para>This describes a single video mode.</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added refresh rate member.</para>
    /// </remarks>
    /// <summary>Gamma ramp.</summary>
    /// <remarks>
    /// <para>This describes the gamma ramp for a monitor.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    /// <summary>Image data.</summary>
    /// <remarks>
    /// <para>This describes a single 2D image.  See the documentation for each related</para>
    /// <para>function what the expected pixel format is.</para>
    /// <para>Added in version 2.1.</para>
    /// <para>Removed format and bytes-per-pixel members.</para>
    /// </remarks>
    /// <summary>Gamepad input state</summary>
    /// <remarks>
    /// <para>This describes the input state of a gamepad.</para>
    /// <para>Added in version 3.3.</para>
    /// </remarks>
    internal unsafe partial class GLFWmonitor
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWmonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWmonitor>();

        protected bool __ownsNativeInstance;

        internal static GLFWmonitor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWmonitor(native.ToPointer(), skipVTables);
        }

        internal static GLFWmonitor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWmonitor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWmonitor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWmonitor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWmonitor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWmonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    internal unsafe partial class GLFWwindow
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWwindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWwindow>();

        protected bool __ownsNativeInstance;

        internal static GLFWwindow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWwindow(native.ToPointer(), skipVTables);
        }

        internal static GLFWwindow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWwindow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWwindow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWwindow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWwindow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWwindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    internal unsafe partial class GLFWcursor
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWcursor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWcursor>();

        protected bool __ownsNativeInstance;

        internal static GLFWcursor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWcursor(native.ToPointer(), skipVTables);
        }

        internal static GLFWcursor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWcursor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWcursor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWcursor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWcursor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWcursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Video mode type.</summary>
    /// <remarks>
    /// <para>This describes a single video mode.</para>
    /// <para>Added in version 1.0.</para>
    /// <para>Added refresh rate member.</para>
    /// </remarks>
    internal unsafe partial class GLFWvidmode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int width;
            internal int height;
            internal int redBits;
            internal int greenBits;
            internal int blueBits;
            internal int refreshRate;

            [SuppressUnmanagedCodeSecurity, DllImport("Glfw", EntryPoint = "??0GLFWvidmode@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWvidmode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWvidmode>();

        protected bool __ownsNativeInstance;

        internal static GLFWvidmode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWvidmode(native.ToPointer(), skipVTables);
        }

        internal static GLFWvidmode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWvidmode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWvidmode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWvidmode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWvidmode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWvidmode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GLFWvidmode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWvidmode(global::Utubz.Internal.Native.Glfw.GLFWvidmode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWvidmode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Glfw.GLFWvidmode.__Internal*) __Instance) = *((global::Utubz.Internal.Native.Glfw.GLFWvidmode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The width, in screen coordinates, of the video mode.</summary>
        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>The height, in screen coordinates, of the video mode.</summary>
        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        /// <summary>The bit depth of the red channel of the video mode.</summary>
        public int RedBits
        {
            get
            {
                return ((__Internal*)__Instance)->redBits;
            }

            set
            {
                ((__Internal*)__Instance)->redBits = value;
            }
        }

        /// <summary>The bit depth of the green channel of the video mode.</summary>
        public int GreenBits
        {
            get
            {
                return ((__Internal*)__Instance)->greenBits;
            }

            set
            {
                ((__Internal*)__Instance)->greenBits = value;
            }
        }

        /// <summary>The bit depth of the blue channel of the video mode.</summary>
        public int BlueBits
        {
            get
            {
                return ((__Internal*)__Instance)->blueBits;
            }

            set
            {
                ((__Internal*)__Instance)->blueBits = value;
            }
        }

        /// <summary>The refresh rate, in Hz, of the video mode.</summary>
        public int RefreshRate
        {
            get
            {
                return ((__Internal*)__Instance)->refreshRate;
            }

            set
            {
                ((__Internal*)__Instance)->refreshRate = value;
            }
        }
    }

    /// <summary>Gamma ramp.</summary>
    /// <remarks>
    /// <para>This describes the gamma ramp for a monitor.</para>
    /// <para>Added in version 3.0.</para>
    /// </remarks>
    internal unsafe partial class GLFWgammaramp : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr red;
            internal __IntPtr green;
            internal __IntPtr blue;
            internal uint size;

            [SuppressUnmanagedCodeSecurity, DllImport("Glfw", EntryPoint = "??0GLFWgammaramp@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWgammaramp> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWgammaramp>();

        protected bool __ownsNativeInstance;

        internal static GLFWgammaramp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWgammaramp(native.ToPointer(), skipVTables);
        }

        internal static GLFWgammaramp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWgammaramp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWgammaramp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWgammaramp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWgammaramp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWgammaramp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GLFWgammaramp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWgammaramp(global::Utubz.Internal.Native.Glfw.GLFWgammaramp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWgammaramp.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Glfw.GLFWgammaramp.__Internal*) __Instance) = *((global::Utubz.Internal.Native.Glfw.GLFWgammaramp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>An array of value describing the response of the red channel.</summary>
        public ushort* Red
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->red;
            }

            set
            {
                ((__Internal*)__Instance)->red = (__IntPtr) value;
            }
        }

        /// <summary>An array of value describing the response of the green channel.</summary>
        public ushort* Green
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->green;
            }

            set
            {
                ((__Internal*)__Instance)->green = (__IntPtr) value;
            }
        }

        /// <summary>An array of value describing the response of the blue channel.</summary>
        public ushort* Blue
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->blue;
            }

            set
            {
                ((__Internal*)__Instance)->blue = (__IntPtr) value;
            }
        }

        /// <summary>The number of elements in each array.</summary>
        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    /// <summary>Image data.</summary>
    /// <remarks>
    /// <para>This describes a single 2D image.  See the documentation for each related</para>
    /// <para>function what the expected pixel format is.</para>
    /// <para>Added in version 2.1.</para>
    /// <para>Removed format and bytes-per-pixel members.</para>
    /// </remarks>
    internal unsafe partial class GLFWimage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int width;
            internal int height;
            internal __IntPtr pixels;

            [SuppressUnmanagedCodeSecurity, DllImport("Glfw", EntryPoint = "??0GLFWimage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWimage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWimage>();

        protected bool __ownsNativeInstance;

        internal static GLFWimage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWimage(native.ToPointer(), skipVTables);
        }

        internal static GLFWimage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWimage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWimage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWimage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWimage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWimage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GLFWimage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWimage(global::Utubz.Internal.Native.Glfw.GLFWimage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWimage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Glfw.GLFWimage.__Internal*) __Instance) = *((global::Utubz.Internal.Native.Glfw.GLFWimage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The width, in pixels, of this image.</summary>
        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>The height, in pixels, of this image.</summary>
        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        /// <summary>The pixel data of this image, arranged left-to-right, top-to-bottom.</summary>
        public byte* Pixels
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->pixels;
            }

            set
            {
                ((__Internal*)__Instance)->pixels = (__IntPtr) value;
            }
        }
    }

    /// <summary>Gamepad input state</summary>
    /// <remarks>
    /// <para>This describes the input state of a gamepad.</para>
    /// <para>Added in version 3.3.</para>
    /// </remarks>
    internal unsafe partial class GLFWgamepadstate : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal fixed byte buttons[15];
            internal fixed float axes[6];

            [SuppressUnmanagedCodeSecurity, DllImport("Glfw", EntryPoint = "??0GLFWgamepadstate@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWgamepadstate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Glfw.GLFWgamepadstate>();

        protected bool __ownsNativeInstance;

        internal static GLFWgamepadstate __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWgamepadstate(native.ToPointer(), skipVTables);
        }

        internal static GLFWgamepadstate __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GLFWgamepadstate)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GLFWgamepadstate __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWgamepadstate(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWgamepadstate(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GLFWgamepadstate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GLFWgamepadstate()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWgamepadstate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public GLFWgamepadstate(global::Utubz.Internal.Native.Glfw.GLFWgamepadstate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Glfw.GLFWgamepadstate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Glfw.GLFWgamepadstate.__Internal*) __Instance) = *((global::Utubz.Internal.Native.Glfw.GLFWgamepadstate.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The states of each [gamepad button](`GLFW_PRESS`</para>
        /// <para>or `GLFW_RELEASE`.</para>
        /// </summary>
        public byte[] Buttons
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->buttons, 15);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 15; i++)
                        ((__Internal*)__Instance)->buttons[i] = value[i];
                }
            }
        }

        /// <summary>
        /// <para>The states of each [gamepad axis](in the range -1.0</para>
        /// <para>to 1.0 inclusive.</para>
        /// </summary>
        public float[] Axes
        {
            get
            {
                return Utubz.Internal.Native.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->axes, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->axes[i] = value[i];
                }
            }
        }
    }

    internal static unsafe partial class glfw3
    {
        public static partial class __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwInit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwInit();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwTerminate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwTerminate();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwInitHint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwInitHint(int hint, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetVersion(int* major, int* minor, int* rev);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetVersionString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetVersionString();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetError", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetError(sbyte** description);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetErrorCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetErrorCallback(__IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitors", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetMonitors(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetPrimaryMonitor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetPrimaryMonitor();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetMonitorPos(__IntPtr monitor, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorWorkarea", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetMonitorWorkarea(__IntPtr monitor, int* xpos, int* ypos, int* width, int* height);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorPhysicalSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetMonitorPhysicalSize(__IntPtr monitor, int* widthMM, int* heightMM);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorContentScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetMonitorContentScale(__IntPtr monitor, float* xscale, float* yscale);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetMonitorName(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetMonitorUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetMonitorUserPointer(__IntPtr monitor, __IntPtr pointer);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMonitorUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetMonitorUserPointer(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetMonitorCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetMonitorCallback(__IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetVideoModes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetVideoModes(__IntPtr monitor, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetVideoMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetVideoMode(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetGamma", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetGamma(__IntPtr monitor, float gamma);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetGammaRamp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetGammaRamp(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetGammaRamp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetGammaRamp(__IntPtr monitor, __IntPtr ramp);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwDefaultWindowHints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwDefaultWindowHints();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwWindowHint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwWindowHint(int hint, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwWindowHintString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwWindowHintString(int hint, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwCreateWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwCreateWindow(int width, int height, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string title, __IntPtr monitor, __IntPtr share);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwDestroyWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwDestroyWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwWindowShouldClose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwWindowShouldClose(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowShouldClose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowShouldClose(__IntPtr window, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowTitle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowTitle(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string title);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowIcon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowIcon(__IntPtr window, int count, __IntPtr images);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetWindowPos(__IntPtr window, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowPos(__IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetWindowSize(__IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowSizeLimits", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowSizeLimits(__IntPtr window, int minwidth, int minheight, int maxwidth, int maxheight);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowAspectRatio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowAspectRatio(__IntPtr window, int numer, int denom);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowSize(__IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetFramebufferSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetFramebufferSize(__IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowFrameSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetWindowFrameSize(__IntPtr window, int* left, int* top, int* right, int* bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowContentScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetWindowContentScale(__IntPtr window, float* xscale, float* yscale);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowOpacity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GlfwGetWindowOpacity(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowOpacity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowOpacity(__IntPtr window, float opacity);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwIconifyWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwIconifyWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwRestoreWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwRestoreWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwMaximizeWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwMaximizeWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwShowWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwShowWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwHideWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwHideWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwFocusWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwFocusWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwRequestWindowAttention", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwRequestWindowAttention(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowMonitor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetWindowMonitor(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowMonitor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowMonitor(__IntPtr window, __IntPtr monitor, int xpos, int ypos, int width, int height, int refreshRate);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowAttrib", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetWindowAttrib(__IntPtr window, int attrib);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowAttrib", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowAttrib(__IntPtr window, int attrib, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetWindowUserPointer(__IntPtr window, __IntPtr pointer);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetWindowUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetWindowUserPointer(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowPosCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowPosCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowSizeCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowSizeCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowCloseCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowCloseCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowRefreshCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowRefreshCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowFocusCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowFocusCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowIconifyCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowIconifyCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowMaximizeCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowMaximizeCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetFramebufferSizeCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetFramebufferSizeCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetWindowContentScaleCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetWindowContentScaleCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwPollEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwPollEvents();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwWaitEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwWaitEvents();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwWaitEventsTimeout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwWaitEventsTimeout(double timeout);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwPostEmptyEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwPostEmptyEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetInputMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetInputMode(__IntPtr window, int mode);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetInputMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetInputMode(__IntPtr window, int mode, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwRawMouseMotionSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwRawMouseMotionSupported();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetKeyName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetKeyName(int key, int scancode);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetKeyScancode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetKeyScancode(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetKey(__IntPtr window, int key);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetMouseButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetMouseButton(__IntPtr window, int button);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwGetCursorPos(__IntPtr window, double* xpos, double* ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetCursorPos(__IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwCreateCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwCreateCursor(__IntPtr image, int xhot, int yhot);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwCreateStandardCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwCreateStandardCursor(int shape);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwDestroyCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwDestroyCursor(__IntPtr cursor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetCursor(__IntPtr window, __IntPtr cursor);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetKeyCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetKeyCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCharCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetCharCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCharModsCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetCharModsCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetMouseButtonCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetMouseButtonCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCursorPosCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetCursorPosCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetCursorEnterCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetCursorEnterCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetScrollCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetScrollCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetDropCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetDropCallback(__IntPtr window, __IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwJoystickPresent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwJoystickPresent(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickAxes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float* GlfwGetJoystickAxes(int jid, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickButtons", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* GlfwGetJoystickButtons(int jid, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickHats", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* GlfwGetJoystickHats(int jid, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetJoystickName(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickGUID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetJoystickGUID(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetJoystickUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetJoystickUserPointer(int jid, __IntPtr pointer);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetJoystickUserPointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetJoystickUserPointer(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwJoystickIsGamepad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwJoystickIsGamepad(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetJoystickCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwSetJoystickCallback(__IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwUpdateGamepadMappings", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwUpdateGamepadMappings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string @string);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetGamepadName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetGamepadName(int jid);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetGamepadState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwGetGamepadState(int jid, __IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetClipboardString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetClipboardString(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string @string);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetClipboardString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetClipboardString(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetTime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double GlfwGetTime();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSetTime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSetTime(double time);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetTimerValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GlfwGetTimerValue();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetTimerFrequency", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GlfwGetTimerFrequency();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwMakeContextCurrent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwMakeContextCurrent(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSwapBuffers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSwapBuffers(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwSwapInterval", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GlfwSwapInterval(int interval);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwExtensionSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwExtensionSupported([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string extension);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetProcAddress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GlfwGetProcAddress([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(Utubz.Internal.Native.UTF8Marshaller))] string procname);

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwVulkanSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GlfwVulkanSupported();

            [SuppressUnmanagedCodeSecurity, DllImport("glfw3", EntryPoint = "glfwGetRequiredInstanceExtensions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte** GlfwGetRequiredInstanceExtensions(uint* count);
        }

        /// <summary>Initializes the GLFW library.</summary>
        /// <returns>
        /// <para>`GLFW_TRUE` if successful, or `GLFW_FALSE` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function initializes the GLFW library.  Before most GLFW functions can</para>
        /// <para>be used, GLFW must be initialized, and before an application terminates GLFW</para>
        /// <para>should be terminated in order to free any resources allocated during or</para>
        /// <para>after initialization.</para>
        /// <para>If this function fails, it callsbefore returning.  If it</para>
        /// <para>succeeds, you should callbefore the application exits.</para>
        /// <para>Additional calls to this function after successful initialization but before</para>
        /// <para>termination will return `GLFW_TRUE` immediately.</para>
        /// <para>This function will change the current directory of the</para>
        /// <para>application to the `Contents/Resources` subdirectory of the application's</para>
        /// <para>bundle, if present.  This can be disabled with theinit hint.</para>
        /// <para>This function will set the `LC_CTYPE` category of the</para>
        /// <para>application locale according to the current environment if that category is</para>
        /// <para>still &quot;C&quot;.  This is because the &quot;C&quot; locale breaks Unicode text input.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static int GlfwInit()
        {
            var __ret = __Internal.GlfwInit();
            return __ret;
        }

        /// <summary>Terminates the GLFW library.</summary>
        /// <remarks>
        /// <para>This function destroys all remaining windows and cursors, restores any</para>
        /// <para>modified gamma ramps and frees any other allocated resources.  Once this</para>
        /// <para>function is called, you must again callsuccessfully before</para>
        /// <para>you will be able to use most GLFW functions.</para>
        /// <para>If GLFW has been successfully initialized, this function should be called</para>
        /// <para>before the application exits.  If initialization fails, there is no need to</para>
        /// <para>call this function, as it is called bybefore it returns</para>
        /// <para>failure.</para>
        /// <para>This function has no effect if GLFW is not initialized.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called before</para>
        /// <para>The contexts of any remaining windows must not be current on any</para>
        /// <para>other thread when this function is called.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwTerminate()
        {
            __Internal.GlfwTerminate();
        }

        /// <summary>Sets the specified init hint to the desired value.</summary>
        /// <param name="hint">The [init hint](to set.</param>
        /// <param name="value">The new value of the init hint.</param>
        /// <remarks>
        /// <para>This function sets hints for the next initialization of GLFW.</para>
        /// <para>The values you set hints to are never reset by GLFW, but they only take</para>
        /// <para>effect during initialization.  Once GLFW has been initialized, any values</para>
        /// <para>you set will be ignored until the library is terminated and initialized</para>
        /// <para>again.</para>
        /// <para>Some hints are platform specific.  These may be set on any platform but they</para>
        /// <para>will only affect their specific platform.  Other platforms will ignore them.</para>
        /// <para>Setting these hints requires no platform specific headers or functions.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function may be called before</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>init_hints</para>
        /// <para>glfwInit</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwInitHint(int hint, int value)
        {
            __Internal.GlfwInitHint(hint, value);
        }

        /// <summary>Retrieves the version of the GLFW library.</summary>
        /// <param name="major">Where to store the major version number, or `NULL`.</param>
        /// <param name="minor">Where to store the minor version number, or `NULL`.</param>
        /// <param name="rev">Where to store the revision number, or `NULL`.</param>
        /// <remarks>
        /// <para>This function retrieves the major, minor and revision numbers of the GLFW</para>
        /// <para>library.  It is intended for when you are using GLFW as a shared library and</para>
        /// <para>want to ensure that you are using the minimum required version.</para>
        /// <para>Any or all of the version arguments may be `NULL`.</para>
        /// <para>None.</para>
        /// <para>This function may be called before</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwGetVersion(ref int major, ref int minor, ref int rev)
        {
            fixed (int* __major0 = &major)
            {
                var __arg0 = __major0;
                fixed (int* __minor1 = &minor)
                {
                    var __arg1 = __minor1;
                    fixed (int* __rev2 = &rev)
                    {
                        var __arg2 = __rev2;
                        __Internal.GlfwGetVersion(__arg0, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>Returns a string describing the compile-time configuration.</summary>
        /// <returns>
        /// <para>The ASCII encoded GLFW version string.</para>
        /// <para>None.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the compile-time generated</para>
        /// <para>[version string](of the GLFW library binary.  It</para>
        /// <para>describes the version, platform, compiler and any platform-specific</para>
        /// <para>compile-time options.  It should not be confused with the OpenGL or OpenGL</para>
        /// <para>ES version string, queried with `glGetString`.</para>
        /// <para>__Do not use the version string__ to parse the GLFW library version.  The</para>
        /// <para>function provides the version of the running library</para>
        /// <para>binary in numerical format.</para>
        /// <para>This function may be called before</para>
        /// <para>The returned string is static and compile-time generated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetVersionString()
        {
            var __ret = __Internal.GlfwGetVersionString();
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns and clears the last error for the calling thread.</summary>
        /// <param name="description">Where to store the error description pointer, or `NULL`.</param>
        /// <returns>
        /// <para>The last error code for the calling thread, or(zero).</para>
        /// <para>None.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        /// <para>next error occurs or the library is terminated.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns and clears the [error code](of the last</para>
        /// <para>error that occurred on the calling thread, and optionally a UTF-8 encoded</para>
        /// <para>human-readable description of it.  If no error has occurred since the last</para>
        /// <para>call, it returns(zero) and the description pointer is</para>
        /// <para>set to `NULL`.</para>
        /// <para>This function may be called before</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwGetError(ref string description)
        {
            sbyte** __arg0 = stackalloc sbyte*[512];
            var __ret = __Internal.GlfwGetError(__arg0);
            description = (string)UTF8Marshaller.marshaler.MarshalNativeToManaged((__IntPtr)(*__arg0));
            Marshal.FreeHGlobal((__IntPtr)(*__arg0));
            return __ret;
        }

        /// <summary>Sets the error callback.</summary>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set.</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[callback pointer type](</para>
        /// <para>None.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the error callback, which is called with an error code</para>
        /// <para>and a human-readable description each time a GLFW error occurs.</para>
        /// <para>The error code is set before the callback is called.  Callingfrom the error callback will return the same value as the error</para>
        /// <para>code argument.</para>
        /// <para>The error callback is called on the thread where the error occurred.  If you</para>
        /// <para>are using GLFW from multiple threads, your error callback needs to be</para>
        /// <para>written accordingly.</para>
        /// <para>Because the description string may have been generated specifically for that</para>
        /// <para>error, it is not guaranteed to be valid after the callback has returned.  If</para>
        /// <para>you wish to use it after the callback returns, you need to make a copy.</para>
        /// <para>Once set, the error callback remains set even after the library has been</para>
        /// <para>terminated.</para>
        /// <para>This function may be called before</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWerrorfun GlfwSetErrorCallback(global::Utubz.Internal.Native.Glfw.GLFWerrorfun callback)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetErrorCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWerrorfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWerrorfun));
        }

        /// <summary>Returns the currently connected monitors.</summary>
        /// <param name="count">
        /// <para>Where to store the number of monitors in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of monitor handles, or `NULL` if no monitors were found or</para>
        /// <para>if an [error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        /// <para>monitor configuration changes or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of handles for all currently connected</para>
        /// <para>monitors.  The primary monitor is always first in the returned array.  If no</para>
        /// <para>monitors were found, this function returns `NULL`.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWmonitor GlfwGetMonitors(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var __ret = __Internal.GlfwGetMonitors(__arg0);
                __IntPtr ____ret = __ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) __ret);
                var __result0 = global::Utubz.Internal.Native.Glfw.GLFWmonitor.__GetOrCreateInstance(____ret, false);
                return __result0;
            }
        }

        /// <summary>Returns the primary monitor.</summary>
        /// <returns>
        /// <para>The primary monitor, or `NULL` if no monitors were found or if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the primary monitor.  This is usually the monitor</para>
        /// <para>where elements like the task bar or global menu bar are located.</para>
        /// <para>The primary monitor is always first in the array returned by</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWmonitor GlfwGetPrimaryMonitor()
        {
            var __ret = __Internal.GlfwGetPrimaryMonitor();
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWmonitor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Returns the position of the monitor's viewport on the virtual screen.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        /// <param name="ypos">Where to store the monitor y-coordinate, or `NULL`.</param>
        /// <remarks>
        /// <para>This function returns the position, in screen coordinates, of the upper-left</para>
        /// <para>corner of the specified monitor.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetMonitorPos(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, ref int xpos, ref int ypos)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            fixed (int* __xpos1 = &xpos)
            {
                var __arg1 = __xpos1;
                fixed (int* __ypos2 = &ypos)
                {
                    var __arg2 = __ypos2;
                    __Internal.GlfwGetMonitorPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Retrieves the work area of the monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        /// <param name="ypos">Where to store the monitor y-coordinate, or `NULL`.</param>
        /// <param name="width">Where to store the monitor width, or `NULL`.</param>
        /// <param name="height">Where to store the monitor height, or `NULL`.</param>
        /// <remarks>
        /// <para>This function returns the position, in screen coordinates, of the upper-left</para>
        /// <para>corner of the work area of the specified monitor along with the work area</para>
        /// <para>size in screen coordinates. The work area is defined as the area of the</para>
        /// <para>monitor not occluded by the operating system task bar where present. If no</para>
        /// <para>task bar exists then the work area is the monitor resolution in screen</para>
        /// <para>coordinates.</para>
        /// <para>Any or all of the position and size arguments may be `NULL`.  If an error</para>
        /// <para>occurs, all non-`NULL` position and size arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwGetMonitorWorkarea(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, ref int xpos, ref int ypos, ref int width, ref int height)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            fixed (int* __xpos1 = &xpos)
            {
                var __arg1 = __xpos1;
                fixed (int* __ypos2 = &ypos)
                {
                    var __arg2 = __ypos2;
                    fixed (int* __width3 = &width)
                    {
                        var __arg3 = __width3;
                        fixed (int* __height4 = &height)
                        {
                            var __arg4 = __height4;
                            __Internal.GlfwGetMonitorWorkarea(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Returns the physical size of the monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="widthMM">
        /// <para>Where to store the width, in millimetres, of the</para>
        /// <para>monitor's display area, or `NULL`.</para>
        /// </param>
        /// <param name="heightMM">
        /// <para>Where to store the height, in millimetres, of the</para>
        /// <para>monitor's display area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the size, in millimetres, of the display area of the</para>
        /// <para>specified monitor.</para>
        /// <para>Some systems do not provide accurate monitor size information, either</para>
        /// <para>because the monitor</para>
        /// <para>[EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)</para>
        /// <para>data is incorrect or because the driver does not report it accurately.</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors include</para>
        /// <para>On Windows 8 and earlier the physical size is calculated from</para>
        /// <para>the current resolution and system DPI instead of querying the monitor EDID data.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetMonitorPhysicalSize(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, ref int widthMM, ref int heightMM)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            fixed (int* __widthMM1 = &widthMM)
            {
                var __arg1 = __widthMM1;
                fixed (int* __heightMM2 = &heightMM)
                {
                    var __arg2 = __heightMM2;
                    __Internal.GlfwGetMonitorPhysicalSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Retrieves the content scale for the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xscale">Where to store the x-axis content scale, or `NULL`.</param>
        /// <param name="yscale">Where to store the y-axis content scale, or `NULL`.</param>
        /// <remarks>
        /// <para>This function retrieves the content scale for the specified monitor.  The</para>
        /// <para>content scale is the ratio between the current DPI and the platform's</para>
        /// <para>default DPI.  This is especially important for text and any UI elements.  If</para>
        /// <para>the pixel dimensions of your UI scaled by this look appropriate on your</para>
        /// <para>machine then it should appear at a reasonable size on other machines</para>
        /// <para>regardless of their DPI and scaling settings.  This relies on the system DPI</para>
        /// <para>and scaling settings being somewhat correct.</para>
        /// <para>The content scale may depend on both the monitor resolution and pixel</para>
        /// <para>density and on user settings.  It may be very different from the raw DPI</para>
        /// <para>calculated from the physical size and current resolution.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwGetMonitorContentScale(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, ref float xscale, ref float yscale)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            fixed (float* __xscale1 = &xscale)
            {
                var __arg1 = __xscale1;
                fixed (float* __yscale2 = &yscale)
                {
                    var __arg2 = __yscale2;
                    __Internal.GlfwGetMonitorContentScale(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Returns the name of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded name of the monitor, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns a human-readable name, encoded as UTF-8, of the</para>
        /// <para>specified monitor.  The name typically reflects the make and model of the</para>
        /// <para>monitor and is not guaranteed to be unique among the connected monitors.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetMonitorName(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetMonitorName(__arg0);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the user pointer of the specified monitor.</summary>
        /// <param name="monitor">The monitor whose pointer to set.</param>
        /// <param name="pointer">The new value.</param>
        /// <remarks>
        /// <para>This function sets the user-defined pointer of the specified monitor.  The</para>
        /// <para>current value is retained until the monitor is disconnected.  The initial</para>
        /// <para>value is `NULL`.</para>
        /// <para>This function may be called from the monitor callback, even for a monitor</para>
        /// <para>that is being disconnected.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwSetMonitorUserPointer(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, __IntPtr pointer)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetMonitorUserPointer(__arg0, pointer);
        }

        /// <summary>Returns the user pointer of the specified monitor.</summary>
        /// <param name="monitor">The monitor whose pointer to return.</param>
        /// <remarks>
        /// <para>This function returns the current value of the user-defined pointer of the</para>
        /// <para>specified monitor.  The initial value is `NULL`.</para>
        /// <para>This function may be called from the monitor callback, even for a monitor</para>
        /// <para>that is being disconnected.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static __IntPtr GlfwGetMonitorUserPointer(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetMonitorUserPointer(__arg0);
            return __ret;
        }

        /// <summary>Sets the monitor configuration callback.</summary>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the monitor configuration callback, or removes the</para>
        /// <para>currently set callback.  This is called when a monitor is connected to or</para>
        /// <para>disconnected from the system.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWmonitorfun GlfwSetMonitorCallback(global::Utubz.Internal.Native.Glfw.GLFWmonitorfun callback)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetMonitorCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWmonitorfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWmonitorfun));
        }

        /// <summary>Returns the available video modes for the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="count">
        /// <para>Where to store the number of video modes in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of video modes, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected, this function is called again for that monitor or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of all video modes supported by the specified</para>
        /// <para>monitor.  The returned array is sorted in ascending order, first by color</para>
        /// <para>bit depth (the sum of all channel depths), then by resolution area (the</para>
        /// <para>product of width and height), then resolution width and finally by refresh</para>
        /// <para>rate.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Changed to return an array of modes for a specific monitor.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWvidmode GlfwGetVideoModes(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, ref int count)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GlfwGetVideoModes(__arg0, __arg1);
                var __result0 = global::Utubz.Internal.Native.Glfw.GLFWvidmode.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        /// <summary>Returns the current mode of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The current mode of the monitor, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified monitor is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current video mode of the specified monitor.  If</para>
        /// <para>you have created a full screen window for that monitor, the return value</para>
        /// <para>will depend on whether that window is iconified.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetDesktopMode`.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWvidmode GlfwGetVideoMode(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetVideoMode(__arg0);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWvidmode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Generates a gamma ramp and sets it for the specified monitor.</summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="gamma">The desired exponent.</param>
        /// <remarks>
        /// <para>This function generates an appropriately sized gamma ramp from the specified</para>
        /// <para>exponent and then callswith it.  The value must be</para>
        /// <para>a finite number greater than zero.</para>
        /// <para>The software controlled gamma ramp is applied _in addition_ to the hardware</para>
        /// <para>gamma correction, which today is usually an approximation of sRGB gamma.</para>
        /// <para>This means that setting a perfectly linear ramp, or gamma 1.0, will produce</para>
        /// <para>the default (usually sRGB-like) behavior.</para>
        /// <para>For gamma correct rendering with OpenGL or OpenGL ES, see thehint.</para>
        /// <para>Possible errors includeand</para>
        /// <para>Gamma handling is a privileged protocol, this function</para>
        /// <para>will thus never be implemented and emits</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetGamma(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, float gamma)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetGamma(__arg0, gamma);
        }

        /// <summary>Returns the current gamma ramp for the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        /// <para>The current gamma ramp, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current gamma ramp of the specified monitor.</para>
        /// <para>Gamma handling is a privileged protocol, this function</para>
        /// <para>will thus never be implemented and emitswhile</para>
        /// <para>returning `NULL`.</para>
        /// <para>The returned structure and its arrays are allocated and</para>
        /// <para>freed by GLFW.  You should not free them yourself.  They are valid until the</para>
        /// <para>specified monitor is disconnected, this function is called again for that</para>
        /// <para>monitor or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWgammaramp GlfwGetGammaRamp(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __ret = __Internal.GlfwGetGammaRamp(__arg0);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWgammaramp.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Sets the current gamma ramp for the specified monitor.</summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="ramp">The gamma ramp to use.</param>
        /// <remarks>
        /// <para>This function sets the current gamma ramp for the specified monitor.  The</para>
        /// <para>original gamma ramp for that monitor is saved by GLFW the first time this</para>
        /// <para>function is called and is restored by</para>
        /// <para>The software controlled gamma ramp is applied _in addition_ to the hardware</para>
        /// <para>gamma correction, which today is usually an approximation of sRGB gamma.</para>
        /// <para>This means that setting a perfectly linear ramp, or gamma 1.0, will produce</para>
        /// <para>the default (usually sRGB-like) behavior.</para>
        /// <para>For gamma correct rendering with OpenGL or OpenGL ES, see thehint.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The size of the specified gamma ramp should match the size of the</para>
        /// <para>current ramp for that monitor.</para>
        /// <para>The gamma ramp size must be 256.</para>
        /// <para>Gamma handling is a privileged protocol, this function</para>
        /// <para>will thus never be implemented and emits</para>
        /// <para>The specified gamma ramp is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetGammaRamp(global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, global::Utubz.Internal.Native.Glfw.GLFWgammaramp ramp)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __arg1 = ramp is null ? __IntPtr.Zero : ramp.__Instance;
            __Internal.GlfwSetGammaRamp(__arg0, __arg1);
        }

        /// <summary>Resets all window hints to their default values.</summary>
        /// <remarks>
        /// <para>This function resets all window hints to their</para>
        /// <para>[default values](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwDefaultWindowHints()
        {
            __Internal.GlfwDefaultWindowHints();
        }

        /// <summary>Sets the specified window hint to the desired value.</summary>
        /// <param name="hint">The [window hint](to set.</param>
        /// <param name="value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>This function sets hints for the next call toThe</para>
        /// <para>hints, once set, retain their values until changed by a call to this</para>
        /// <para>function oror until the library is terminated.</para>
        /// <para>Only integer value hints can be set with this function.  String value hints</para>
        /// <para>are set with</para>
        /// <para>This function does not check whether the specified hint values are valid.</para>
        /// <para>If you set hints to invalid values this will instead be reported by the next</para>
        /// <para>call to</para>
        /// <para>Some hints are platform specific.  These may be set on any platform but they</para>
        /// <para>will only affect their specific platform.  Other platforms will ignore them.</para>
        /// <para>Setting these hints requires no platform specific headers or functions.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwOpenWindowHint`.</para>
        /// </remarks>
        public static void GlfwWindowHint(int hint, int value)
        {
            __Internal.GlfwWindowHint(hint, value);
        }

        /// <summary>Sets the specified window hint to the desired value.</summary>
        /// <param name="hint">The [window hint](to set.</param>
        /// <param name="value">The new value of the window hint.</param>
        /// <remarks>
        /// <para>This function sets hints for the next call toThe</para>
        /// <para>hints, once set, retain their values until changed by a call to this</para>
        /// <para>function oror until the library is terminated.</para>
        /// <para>Only string type hints can be set with this function.  Integer value hints</para>
        /// <para>are set with</para>
        /// <para>This function does not check whether the specified hint values are valid.</para>
        /// <para>If you set hints to invalid values this will instead be reported by the next</para>
        /// <para>call to</para>
        /// <para>Some hints are platform specific.  These may be set on any platform but they</para>
        /// <para>will only affect their specific platform.  Other platforms will ignore them.</para>
        /// <para>Setting these hints requires no platform specific headers or functions.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The specified string is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwWindowHintString(int hint, string value)
        {
            __Internal.GlfwWindowHintString(hint, value);
        }

        /// <summary>Creates a window and its associated context.</summary>
        /// <param name="width">
        /// <para>The desired width, in screen coordinates, of the window.</para>
        /// <para>This must be greater than zero.</para>
        /// </param>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the window.</para>
        /// <para>This must be greater than zero.</para>
        /// </param>
        /// <param name="title">The initial, UTF-8 encoded window title.</param>
        /// <param name="monitor">
        /// <para>The monitor to use for full screen mode, or `NULL` for</para>
        /// <para>windowed mode.</para>
        /// </param>
        /// <param name="share">
        /// <para>The window whose context to share resources with, or `NULL`</para>
        /// <para>to not share resources.</para>
        /// </param>
        /// <returns>
        /// <para>The handle of the created window, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>Screensaver inhibition requires the idle-inhibit protocol</para>
        /// <para>to be implemented in the user's compositor.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>A full screen window will not attempt to change the mode,</para>
        /// <para>no matter what the requested size or refresh rate.</para>
        /// <para>Compositors should implement the xdg-decoration protocol</para>
        /// <para>for GLFW to decorate the window properly.  If this protocol isn't</para>
        /// <para>supported, or if the compositor prefers client-side decorations, a very</para>
        /// <para>simple fallback frame will be drawn using the wp_viewporter protocol.  A</para>
        /// <para>compositor can still emit close, maximize or fullscreen events, using for</para>
        /// <para>instance a keybind mechanism.  If neither of these protocols is supported,</para>
        /// <para>the window won't be decorated.</para>
        /// <para>The class part of the `WM_CLASS` window property will by</para>
        /// <para>default be set to the window title passed to this function.  The instance</para>
        /// <para>part will use the contents of the `RESOURCE_NAME` environment variable, if</para>
        /// <para>present and not empty, or fall back to the window title.  Set the</para>
        /// <para>[GLFW_X11_CLASS_NAME](and</para>
        /// <para>[GLFW_X11_INSTANCE_NAME](window hints to</para>
        /// <para>override this.</para>
        /// <para>Due to the asynchronous nature of X11, it may take a moment for</para>
        /// <para>a window to reach its requested state.  This means you may not be able to</para>
        /// <para>query the final size, position or other attributes directly after window</para>
        /// <para>creation.</para>
        /// <para>Some window managers will not respect the placement of</para>
        /// <para>initially hidden windows.</para>
        /// <para>When activating frame autosaving with</para>
        /// <para>[GLFW_COCOA_FRAME_NAME](the specified</para>
        /// <para>window size and position may be overridden by previously saved values.</para>
        /// <para>The OS only supports forward-compatible core profile contexts</para>
        /// <para>for OpenGL versions 3.2 and later.  Before creating an OpenGL context of</para>
        /// <para>version 3.2 or later you must set the</para>
        /// <para>[GLFW_OPENGL_FORWARD_COMPAT](and</para>
        /// <para>[GLFW_OPENGL_PROFILE](hints accordingly.</para>
        /// <para>OpenGL 3.0 and 3.1 contexts are not supported at all on macOS.</para>
        /// <para>The first time a window is created the menu bar is created.</para>
        /// <para>If GLFW finds a `MainMenu.nib` it is loaded and assumed to contain a menu</para>
        /// <para>bar.  Otherwise a minimal menu bar is created manually with common commands</para>
        /// <para>like Hide, Quit and About.  The About entry opens a minimal about dialog</para>
        /// <para>with information from the application's bundle.  Menu bar creation can be</para>
        /// <para>disabled entirely with theinit hint.</para>
        /// <para>The GLFW window has no icon, as it is not a document</para>
        /// <para>window, but the dock icon will be the same as the application bundle's icon.</para>
        /// <para>For more information on bundles, see the</para>
        /// <para>[Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)</para>
        /// <para>in the Mac Developer Library.</para>
        /// <para>The context to share resources with must not be current on</para>
        /// <para>any other thread.</para>
        /// <para>If the executable has an icon resource named `GLFW_ICON,` it</para>
        /// <para>will be set as the initial icon for the window.  If no such icon is present,</para>
        /// <para>the `IDI_APPLICATION` icon will be used instead.  To set a different icon,</para>
        /// <para>see</para>
        /// <para>Window creation will fail if the Microsoft GDI software</para>
        /// <para>OpenGL implementation is the only one available.</para>
        /// <para>This function creates a window and its associated OpenGL or OpenGL ES</para>
        /// <para>context.  Most of the options controlling how the window and its context</para>
        /// <para>should be created are specified with [window hints](</para>
        /// <para>Successful creation does not change which context is current.  Before you</para>
        /// <para>can use the newly created context, you need to</para>
        /// <para>[make it current](For information about the `share`</para>
        /// <para>parameter, see</para>
        /// <para>The created window, framebuffer and context may differ from what you</para>
        /// <para>requested, as not all parameters and hints are</para>
        /// <para>[hard constraints](This includes the size of the</para>
        /// <para>window, especially for full screen windows.  To query the actual attributes</para>
        /// <para>of the created window, framebuffer and context, seeand</para>
        /// <para>To create a full screen window, you need to specify the monitor the window</para>
        /// <para>will cover.  If no monitor is specified, the window will be windowed mode.</para>
        /// <para>Unless you have a way for the user to choose a specific monitor, it is</para>
        /// <para>recommended that you pick the primary monitor.  For more information on how</para>
        /// <para>to query connected monitors, see</para>
        /// <para>For full screen windows, the specified size becomes the resolution of the</para>
        /// <para>window's _desired video mode_.  As long as a full screen window is not</para>
        /// <para>iconified, the supported video mode most closely matching the desired video</para>
        /// <para>mode is set for the specified monitor.  For more information about full</para>
        /// <para>screen windows, including the creation of so called _windowed full screen_</para>
        /// <para>or _borderless full screen_ windows, see</para>
        /// <para>Once you have created the window, you can switch it between windowed and</para>
        /// <para>full screen mode withThis will not affect its</para>
        /// <para>OpenGL or OpenGL ES context.</para>
        /// <para>By default, newly created windows use the placement recommended by the</para>
        /// <para>window system.  To create the window at a specific position, make it</para>
        /// <para>initially invisible using the [GLFW_VISIBLE](window</para>
        /// <para>hint, set its [position](and then [show](it.</para>
        /// <para>As long as at least one full screen window is not iconified, the screensaver</para>
        /// <para>is prohibited from starting.</para>
        /// <para>Window systems put limits on window sizes.  Very large or very small window</para>
        /// <para>dimensions may be overridden by the window system on creation.  Check the</para>
        /// <para>actual [size](after creation.</para>
        /// <para>The [swap interval](is not set during window creation and</para>
        /// <para>the initial value may vary depending on driver settings and defaults.</para>
        /// <para>On OS X 10.10 and later the window frame will not be rendered</para>
        /// <para>at full resolution on Retina displays unless the</para>
        /// <para>[GLFW_COCOA_RETINA_FRAMEBUFFER](hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the</para>
        /// <para>application bundle's `Info.plist`.  For more information, see</para>
        /// <para>[High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)</para>
        /// <para>in the Mac Developer Library.  The GLFW test and example programs use</para>
        /// <para>a custom `Info.plist` template for this, which can be found as</para>
        /// <para>`CMake/MacOSXBundleInfo.plist.in` in the source tree.</para>
        /// <para>Added in version 3.0.  Replaces `glfwOpenWindow`.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindow GlfwCreateWindow(int width, int height, string title, global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, global::Utubz.Internal.Native.Glfw.GLFWwindow share)
        {
            var __arg3 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            var __arg4 = share is null ? __IntPtr.Zero : share.__Instance;
            var __ret = __Internal.GlfwCreateWindow(width, height, title, __arg3, __arg4);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWwindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Destroys the specified window and its context.</summary>
        /// <param name="window">The window to destroy.</param>
        /// <remarks>
        /// <para>This function destroys the specified window and its context.  On calling</para>
        /// <para>this function, no further callbacks will be called for that window.</para>
        /// <para>If the context of the specified window is current on the main thread, it is</para>
        /// <para>detached before being destroyed.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The context of the specified window must not be current on any other</para>
        /// <para>thread when this function is called.</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwCloseWindow`.</para>
        /// </remarks>
        public static void GlfwDestroyWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwDestroyWindow(__arg0);
        }

        /// <summary>Checks the close flag of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// <para>The value of the close flag.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the value of the close flag of the specified window.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static int GlfwWindowShouldClose(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwWindowShouldClose(__arg0);
            return __ret;
        }

        /// <summary>Sets the close flag of the specified window.</summary>
        /// <param name="window">The window whose flag to change.</param>
        /// <param name="value">The new value.</param>
        /// <remarks>
        /// <para>This function sets the value of the close flag of the specified window.</para>
        /// <para>This can be used to override the user's attempt to close the window, or</para>
        /// <para>to signal that it should be closed.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetWindowShouldClose(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int value)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowShouldClose(__arg0, value);
        }

        /// <summary>Sets the title of the specified window.</summary>
        /// <param name="window">The window whose title to change.</param>
        /// <param name="title">The UTF-8 encoded window title.</param>
        /// <remarks>
        /// <para>This function sets the window title, encoded as UTF-8, of the specified</para>
        /// <para>window.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The window title will not be updated until the next time you</para>
        /// <para>process events.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowTitle(global::Utubz.Internal.Native.Glfw.GLFWwindow window, string title)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowTitle(__arg0, title);
        }

        /// <summary>Sets the icon for the specified window.</summary>
        /// <param name="window">The window whose icon to set.</param>
        /// <param name="count">
        /// <para>The number of images in the specified array, or zero to</para>
        /// <para>revert to the default window icon.</para>
        /// </param>
        /// <param name="images">
        /// <para>The images to create the icon from.  This is ignored if</para>
        /// <para>count is zero.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the icon of the specified window.  If passed an array of</para>
        /// <para>candidate images, those of or closest to the sizes desired by the system are</para>
        /// <para>selected.  If no images are specified, the window reverts to its default</para>
        /// <para>icon.</para>
        /// <para>The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight</para>
        /// <para>bits per channel with the red channel first.  They are arranged canonically</para>
        /// <para>as packed sequential rows, starting from the top-left corner.</para>
        /// <para>The desired image sizes varies depending on platform and system settings.</para>
        /// <para>The selected images will be rescaled as needed.  Good sizes include 16x16,</para>
        /// <para>32x32 and 48x48.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The specified image data is copied before this function</para>
        /// <para>returns.</para>
        /// <para>The GLFW window has no icon, as it is not a document</para>
        /// <para>window, so this function does nothing.  The dock icon will be the same as</para>
        /// <para>the application bundle's icon.  For more information on bundles, see the</para>
        /// <para>[Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)</para>
        /// <para>in the Mac Developer Library.</para>
        /// <para>There is no existing protocol to change an icon, the</para>
        /// <para>window will thus inherit the one defined in the application's desktop file.</para>
        /// <para>This function always emits</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowIcon(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int count, global::Utubz.Internal.Native.Glfw.GLFWimage images)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg2 = images is null ? __IntPtr.Zero : images.__Instance;
            __Internal.GlfwSetWindowIcon(__arg0, count, __arg2);
        }

        /// <summary>Retrieves the position of the content area of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">
        /// <para>Where to store the x-coordinate of the upper-left corner of</para>
        /// <para>the content area, or `NULL`.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>Where to store the y-coordinate of the upper-left corner of</para>
        /// <para>the content area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the position, in screen coordinates, of the</para>
        /// <para>upper-left corner of the content area of the specified window.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>There is no way for an application to retrieve the global</para>
        /// <para>position of its windows, this function will always emit</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetWindowPos(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref int xpos, ref int ypos)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __xpos1 = &xpos)
            {
                var __arg1 = __xpos1;
                fixed (int* __ypos2 = &ypos)
                {
                    var __arg2 = __ypos2;
                    __Internal.GlfwGetWindowPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Sets the position of the content area of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">The x-coordinate of the upper-left corner of the content area.</param>
        /// <param name="ypos">The y-coordinate of the upper-left corner of the content area.</param>
        /// <remarks>
        /// <para>This function sets the position, in screen coordinates, of the upper-left</para>
        /// <para>corner of the content area of the specified windowed mode window.  If the</para>
        /// <para>window is a full screen window, this function does nothing.</para>
        /// <para>__Do not use this function__ to move an already visible window unless you</para>
        /// <para>have very good reasons for doing so, as it will confuse and annoy the user.</para>
        /// <para>The window manager may put limits on what positions are allowed.  GLFW</para>
        /// <para>cannot and should not override these limits.</para>
        /// <para>Possible errors includeand</para>
        /// <para>There is no way for an application to set the global</para>
        /// <para>position of its windows, this function will always emit</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowPos(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int xpos, int ypos)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowPos(__arg0, xpos, ypos);
        }

        /// <summary>Retrieves the size of the content area of the specified window.</summary>
        /// <param name="window">The window whose size to retrieve.</param>
        /// <param name="width">
        /// <para>Where to store the width, in screen coordinates, of the</para>
        /// <para>content area, or `NULL`.</para>
        /// </param>
        /// <param name="height">
        /// <para>Where to store the height, in screen coordinates, of the</para>
        /// <para>content area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in screen coordinates, of the content area</para>
        /// <para>of the specified window.  If you wish to retrieve the size of the</para>
        /// <para>framebuffer of the window in pixels, see</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwGetWindowSize(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __width1 = &width)
            {
                var __arg1 = __width1;
                fixed (int* __height2 = &height)
                {
                    var __arg2 = __height2;
                    __Internal.GlfwGetWindowSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Sets the size limits of the specified window.</summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="minwidth">
        /// <para>The minimum width, in screen coordinates, of the content</para>
        /// <para>area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="minheight">
        /// <para>The minimum height, in screen coordinates, of the</para>
        /// <para>content area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="maxwidth">
        /// <para>The maximum width, in screen coordinates, of the content</para>
        /// <para>area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="maxheight">
        /// <para>The maximum height, in screen coordinates, of the</para>
        /// <para>content area, or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the size limits of the content area of the specified</para>
        /// <para>window.  If the window is full screen, the size limits only take effect</para>
        /// <para>once it is made windowed.  If the window is not resizable, this function</para>
        /// <para>does nothing.</para>
        /// <para>The size limits are applied immediately to a windowed mode window and may</para>
        /// <para>cause it to be resized.</para>
        /// <para>The maximum dimensions must be greater than or equal to the minimum</para>
        /// <para>dimensions and all must be greater than or equal to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>If you set size limits and an aspect ratio that conflict, the</para>
        /// <para>results are undefined.</para>
        /// <para>The size limits will not be applied until the window is</para>
        /// <para>actually resized, either by the user or by the compositor.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowSizeLimits(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSizeLimits(__arg0, minwidth, minheight, maxwidth, maxheight);
        }

        /// <summary>Sets the aspect ratio of the specified window.</summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="numer">
        /// <para>The numerator of the desired aspect ratio, or</para>
        /// <para>`GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="denom">
        /// <para>The denominator of the desired aspect ratio, or</para>
        /// <para>`GLFW_DONT_CARE`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the required aspect ratio of the content area of the</para>
        /// <para>specified window.  If the window is full screen, the aspect ratio only takes</para>
        /// <para>effect once it is made windowed.  If the window is not resizable, this</para>
        /// <para>function does nothing.</para>
        /// <para>The aspect ratio is specified as a numerator and a denominator and both</para>
        /// <para>values must be greater than zero.  For example, the common 16:9 aspect ratio</para>
        /// <para>is specified as 16 and 9, respectively.</para>
        /// <para>If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect</para>
        /// <para>ratio limit is disabled.</para>
        /// <para>The aspect ratio is applied immediately to a windowed mode window and may</para>
        /// <para>cause it to be resized.</para>
        /// <para>Possible errors includeand</para>
        /// <para>If you set size limits and an aspect ratio that conflict, the</para>
        /// <para>results are undefined.</para>
        /// <para>The aspect ratio will not be applied until the window is</para>
        /// <para>actually resized, either by the user or by the compositor.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowAspectRatio(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int numer, int denom)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowAspectRatio(__arg0, numer, denom);
        }

        /// <summary>Sets the size of the content area of the specified window.</summary>
        /// <param name="window">The window to resize.</param>
        /// <param name="width">
        /// <para>The desired width, in screen coordinates, of the window</para>
        /// <para>content area.</para>
        /// </param>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the window</para>
        /// <para>content area.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the size, in screen coordinates, of the content area of</para>
        /// <para>the specified window.</para>
        /// <para>For full screen windows, this function updates the resolution of its desired</para>
        /// <para>video mode and switches to the video mode closest to it, without affecting</para>
        /// <para>the window's context.  As the context is unaffected, the bit depths of the</para>
        /// <para>framebuffer remain unchanged.</para>
        /// <para>If you wish to update the refresh rate of the desired video mode in addition</para>
        /// <para>to its resolution, see</para>
        /// <para>The window manager may put limits on what sizes are allowed.  GLFW cannot</para>
        /// <para>and should not override these limits.</para>
        /// <para>Possible errors includeand</para>
        /// <para>A full screen window will not attempt to change the mode,</para>
        /// <para>no matter what the requested size.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSetWindowSize(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int width, int height)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowSize(__arg0, width, height);
        }

        /// <summary>Retrieves the size of the framebuffer of the specified window.</summary>
        /// <param name="window">The window whose framebuffer to query.</param>
        /// <param name="width">
        /// <para>Where to store the width, in pixels, of the framebuffer,</para>
        /// <para>or `NULL`.</para>
        /// </param>
        /// <param name="height">
        /// <para>Where to store the height, in pixels, of the framebuffer,</para>
        /// <para>or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in pixels, of the framebuffer of the</para>
        /// <para>specified window.  If you wish to retrieve the size of the window in screen</para>
        /// <para>coordinates, see</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwGetFramebufferSize(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref int width, ref int height)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __width1 = &width)
            {
                var __arg1 = __width1;
                fixed (int* __height2 = &height)
                {
                    var __arg2 = __height2;
                    __Internal.GlfwGetFramebufferSize(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Retrieves the size of the frame of the window.</summary>
        /// <param name="window">The window whose frame size to query.</param>
        /// <param name="left">
        /// <para>Where to store the size, in screen coordinates, of the left</para>
        /// <para>edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="top">
        /// <para>Where to store the size, in screen coordinates, of the top</para>
        /// <para>edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="right">
        /// <para>Where to store the size, in screen coordinates, of the</para>
        /// <para>right edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <param name="bottom">
        /// <para>Where to store the size, in screen coordinates, of the</para>
        /// <para>bottom edge of the window frame, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function retrieves the size, in screen coordinates, of each edge of the</para>
        /// <para>frame of the specified window.  This size includes the title bar, if the</para>
        /// <para>window has one.  The size of the frame may vary depending on the</para>
        /// <para>[window-related hints](used to create it.</para>
        /// <para>Because this function retrieves the size of each window frame edge and not</para>
        /// <para>the offset along a particular coordinate axis, the retrieved values will</para>
        /// <para>always be zero or positive.</para>
        /// <para>Any or all of the size arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` size arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwGetWindowFrameSize(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref int left, ref int top, ref int right, ref int bottom)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __left1 = &left)
            {
                var __arg1 = __left1;
                fixed (int* __top2 = &top)
                {
                    var __arg2 = __top2;
                    fixed (int* __right3 = &right)
                    {
                        var __arg3 = __right3;
                        fixed (int* __bottom4 = &bottom)
                        {
                            var __arg4 = __bottom4;
                            __Internal.GlfwGetWindowFrameSize(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Retrieves the content scale for the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xscale">Where to store the x-axis content scale, or `NULL`.</param>
        /// <param name="yscale">Where to store the y-axis content scale, or `NULL`.</param>
        /// <remarks>
        /// <para>This function retrieves the content scale for the specified window.  The</para>
        /// <para>content scale is the ratio between the current DPI and the platform's</para>
        /// <para>default DPI.  This is especially important for text and any UI elements.  If</para>
        /// <para>the pixel dimensions of your UI scaled by this look appropriate on your</para>
        /// <para>machine then it should appear at a reasonable size on other machines</para>
        /// <para>regardless of their DPI and scaling settings.  This relies on the system DPI</para>
        /// <para>and scaling settings being somewhat correct.</para>
        /// <para>On systems where each monitors can have its own content scale, the window</para>
        /// <para>content scale will depend on which monitor the system considers the window</para>
        /// <para>to be on.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwGetWindowContentScale(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref float xscale, ref float yscale)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (float* __xscale1 = &xscale)
            {
                var __arg1 = __xscale1;
                fixed (float* __yscale2 = &yscale)
                {
                    var __arg2 = __yscale2;
                    __Internal.GlfwGetWindowContentScale(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Returns the opacity of the whole window.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// <para>The opacity value of the specified window.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the opacity of the window, including any decorations.</para>
        /// <para>The opacity (or alpha) value is a positive finite number between zero and</para>
        /// <para>one, where zero is fully transparent and one is fully opaque.  If the system</para>
        /// <para>does not support whole window transparency, this function always returns one.</para>
        /// <para>The initial opacity value for newly created windows is one.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static float GlfwGetWindowOpacity(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowOpacity(__arg0);
            return __ret;
        }

        /// <summary>Sets the opacity of the whole window.</summary>
        /// <param name="window">The window to set the opacity for.</param>
        /// <param name="opacity">The desired opacity of the specified window.</param>
        /// <remarks>
        /// <para>This function sets the opacity of the window, including any decorations.</para>
        /// <para>The opacity (or alpha) value is a positive finite number between zero and</para>
        /// <para>one, where zero is fully transparent and one is fully opaque.</para>
        /// <para>The initial opacity value for newly created windows is one.</para>
        /// <para>A window created with framebuffer transparency may not use whole window</para>
        /// <para>transparency.  The results of doing this are undefined.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwSetWindowOpacity(global::Utubz.Internal.Native.Glfw.GLFWwindow window, float opacity)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowOpacity(__arg0, opacity);
        }

        /// <summary>Iconifies the specified window.</summary>
        /// <param name="window">The window to iconify.</param>
        /// <remarks>
        /// <para>This function iconifies (minimizes) the specified window if it was</para>
        /// <para>previously restored.  If the window is already iconified, this function does</para>
        /// <para>nothing.</para>
        /// <para>If the specified window is a full screen window, the original monitor</para>
        /// <para>resolution is restored until the window is restored.</para>
        /// <para>Possible errors includeand</para>
        /// <para>There is no concept of iconification in wl_shell, this</para>
        /// <para>function will emitwhen using this deprecated</para>
        /// <para>protocol.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 2.1.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwIconifyWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwIconifyWindow(__arg0);
        }

        /// <summary>Restores the specified window.</summary>
        /// <param name="window">The window to restore.</param>
        /// <remarks>
        /// <para>This function restores the specified window if it was previously iconified</para>
        /// <para>(minimized) or maximized.  If the window is already restored, this function</para>
        /// <para>does nothing.</para>
        /// <para>If the specified window is a full screen window, the resolution chosen for</para>
        /// <para>the window is restored on the selected monitor.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 2.1.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwRestoreWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwRestoreWindow(__arg0);
        }

        /// <summary>Maximizes the specified window.</summary>
        /// <param name="window">The window to maximize.</param>
        /// <remarks>
        /// <para>This function maximizes the specified window if it was previously not</para>
        /// <para>maximized.  If the window is already maximized, this function does nothing.</para>
        /// <para>If the specified window is a full screen window, this function does nothing.</para>
        /// <para>Possible errors includeand</para>
        /// <para>Thread Safety</para>
        /// <para>This function may only be called from the main thread.</para>
        /// <para>Added in GLFW 3.2.</para>
        /// </remarks>
        public static void GlfwMaximizeWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwMaximizeWindow(__arg0);
        }

        /// <summary>Makes the specified window visible.</summary>
        /// <param name="window">The window to make visible.</param>
        /// <remarks>
        /// <para>This function makes the specified window visible if it was previously</para>
        /// <para>hidden.  If the window is already visible or is in full screen mode, this</para>
        /// <para>function does nothing.</para>
        /// <para>By default, windowed mode windows are focused when shown</para>
        /// <para>Set the [GLFW_FOCUS_ON_SHOW](window hint</para>
        /// <para>to change this behavior for all newly created windows, or change the</para>
        /// <para>behavior for an existing window with</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwShowWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwShowWindow(__arg0);
        }

        /// <summary>Hides the specified window.</summary>
        /// <param name="window">The window to hide.</param>
        /// <remarks>
        /// <para>This function hides the specified window if it was previously visible.  If</para>
        /// <para>the window is already hidden or is in full screen mode, this function does</para>
        /// <para>nothing.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwHideWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwHideWindow(__arg0);
        }

        /// <summary>Brings the specified window to front and sets input focus.</summary>
        /// <param name="window">The window to give input focus.</param>
        /// <remarks>
        /// <para>This function brings the specified window to front and sets input focus.</para>
        /// <para>The window should already be visible and not iconified.</para>
        /// <para>By default, both windowed and full screen mode windows are focused when</para>
        /// <para>initially created.  Set the [GLFW_FOCUSED](to</para>
        /// <para>disable this behavior.</para>
        /// <para>Also by default, windowed mode windows are focused when shown</para>
        /// <para>withSet the</para>
        /// <para>[GLFW_FOCUS_ON_SHOW](to disable this behavior.</para>
        /// <para>__Do not use this function__ to steal focus from other applications unless</para>
        /// <para>you are certain that is what the user wants.  Focus stealing can be</para>
        /// <para>extremely disruptive.</para>
        /// <para>For a less disruptive way of getting the user's attention, see</para>
        /// <para>[attention requests](</para>
        /// <para>Possible errors includeand</para>
        /// <para>It is not possible for an application to bring its windows</para>
        /// <para>to front, this function will always emit</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwFocusWindow(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwFocusWindow(__arg0);
        }

        /// <summary>Requests user attention to the specified window.</summary>
        /// <param name="window">The window to request attention to.</param>
        /// <remarks>
        /// <para>This function requests user attention to the specified window.  On</para>
        /// <para>platforms where this is not supported, attention is requested to the</para>
        /// <para>application as a whole.</para>
        /// <para>Once the user has given attention, usually by focusing the window or</para>
        /// <para>application, the system will end the request automatically.</para>
        /// <para>Possible errors includeand</para>
        /// <para>Attention is requested to the application as a whole, not the</para>
        /// <para>specific window.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwRequestWindowAttention(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwRequestWindowAttention(__arg0);
        }

        /// <summary>Returns the monitor that the window uses for full screen mode.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        /// <para>The monitor, or `NULL` if the window is in windowed mode or an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the handle of the monitor that the specified window is</para>
        /// <para>in full screen on.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWmonitor GlfwGetWindowMonitor(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowMonitor(__arg0);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWmonitor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Sets the mode, monitor, video mode and placement of a window.</summary>
        /// <param name="height">
        /// <para>The desired height, in screen coordinates, of the content</para>
        /// <para>area or video mode.</para>
        /// </param>
        /// <param name="width">
        /// <para>The desired with, in screen coordinates, of the content</para>
        /// <para>area or video mode.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>The desired y-coordinate of the upper-left corner of the</para>
        /// <para>content area.</para>
        /// </param>
        /// <param name="refreshRate">
        /// <para>The desired refresh rate, in Hz, of the video mode,</para>
        /// <para>or `GLFW_DONT_CARE`.</para>
        /// </param>
        /// <param name="monitor">The desired monitor, or `NULL` to set windowed mode.</param>
        /// <param name="window">The window whose monitor, size or video mode to set.</param>
        /// <param name="xpos">
        /// <para>The desired x-coordinate of the upper-left corner of the</para>
        /// <para>content area.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the monitor that the window uses for full screen mode or,</para>
        /// <para>if the monitor is `NULL`, makes it windowed mode.</para>
        /// <para>When setting a monitor, this function updates the width, height and refresh</para>
        /// <para>rate of the desired video mode and switches to the video mode closest to it.</para>
        /// <para>The window position is ignored when setting a monitor.</para>
        /// <para>When the monitor is `NULL`, the position, width and height are used to</para>
        /// <para>place the window content area.  The refresh rate is ignored when no monitor</para>
        /// <para>is specified.</para>
        /// <para>If you only wish to update the resolution of a full screen window or the</para>
        /// <para>size of a windowed mode window, see</para>
        /// <para>When a window transitions from full screen to windowed mode, this function</para>
        /// <para>restores any previous window settings such as whether it is decorated,</para>
        /// <para>floating, resizable, has size or aspect ratio limits, etc.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The OpenGL or OpenGL ES context will not be destroyed or otherwise</para>
        /// <para>affected by any resizing or mode switching, although you may need to update</para>
        /// <para>your viewport if the framebuffer size has changed.</para>
        /// <para>The desired window position is ignored, as there is no way</para>
        /// <para>for an application to set this property.</para>
        /// <para>Setting the window to full screen will not attempt to</para>
        /// <para>change the mode, no matter what the requested size or refresh rate.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwSetWindowMonitor(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWmonitor monitor, int xpos, int ypos, int width, int height, int refreshRate)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            __Internal.GlfwSetWindowMonitor(__arg0, __arg1, xpos, ypos, width, height, refreshRate);
        }

        /// <summary>Returns an attribute of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="attrib">
        /// <para>The [window attribute](whose value to</para>
        /// <para>return.</para>
        /// </param>
        /// <returns>
        /// <para>The value of the attribute, or zero if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the value of an attribute of the specified window or</para>
        /// <para>its OpenGL or OpenGL ES context.</para>
        /// <para>Framebuffer related hints are not window attributes.  Seefor more information.</para>
        /// <para>Zero is a valid value for many window and context related</para>
        /// <para>attributes so you cannot use a return value of zero as an indication of</para>
        /// <para>errors.  However, this function should not fail as long as it is passed</para>
        /// <para>valid arguments and the library has been [initialized](</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetWindowParam` and</para>
        /// <para>`glfwGetGLVersion`.</para>
        /// </remarks>
        public static int GlfwGetWindowAttrib(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int attrib)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowAttrib(__arg0, attrib);
            return __ret;
        }

        /// <summary>Sets an attribute of the specified window.</summary>
        /// <param name="window">The window to set the attribute for.</param>
        /// <param name="attrib">A supported window attribute.</param>
        /// <param name="value">`GLFW_TRUE` or `GLFW_FALSE`.</param>
        /// <remarks>
        /// <para>This function sets the value of an attribute of the specified window.</para>
        /// <para>The supported attributes are [GLFW_DECORATED]([GLFW_RESIZABLE]([GLFW_FLOATING]([GLFW_AUTO_ICONIFY](and</para>
        /// <para>[GLFW_FOCUS_ON_SHOW](</para>
        /// <para>Some of these attributes are ignored for full screen windows.  The new</para>
        /// <para>value will take effect if the window is later made windowed.</para>
        /// <para>Some of these attributes are ignored for windowed mode windows.  The new</para>
        /// <para>value will take effect if the window is later made full screen.</para>
        /// <para>Possible errors includeand</para>
        /// <para>Callingwill always return the latest</para>
        /// <para>value, even if that value is ignored by the current mode of the window.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwSetWindowAttrib(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int attrib, int value)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowAttrib(__arg0, attrib, value);
        }

        /// <summary>Sets the user pointer of the specified window.</summary>
        /// <param name="window">The window whose pointer to set.</param>
        /// <param name="pointer">The new value.</param>
        /// <remarks>
        /// <para>This function sets the user-defined pointer of the specified window.  The</para>
        /// <para>current value is retained until the window is destroyed.  The initial value</para>
        /// <para>is `NULL`.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetWindowUserPointer(global::Utubz.Internal.Native.Glfw.GLFWwindow window, __IntPtr pointer)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetWindowUserPointer(__arg0, pointer);
        }

        /// <summary>Returns the user pointer of the specified window.</summary>
        /// <param name="window">The window whose pointer to return.</param>
        /// <remarks>
        /// <para>This function returns the current value of the user-defined pointer of the</para>
        /// <para>specified window.  The initial value is `NULL`.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static __IntPtr GlfwGetWindowUserPointer(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetWindowUserPointer(__arg0);
            return __ret;
        }

        /// <summary>Sets the position callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the position callback of the specified window, which is</para>
        /// <para>called when the window is moved.  The callback is provided with the</para>
        /// <para>position, in screen coordinates, of the upper-left corner of the content</para>
        /// <para>area of the window.</para>
        /// <para>This callback will never be called, as there is no way for</para>
        /// <para>an application to know its global position.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowposfun GlfwSetWindowPosCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowposfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowPosCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowposfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowposfun));
        }

        /// <summary>Sets the size callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the size callback of the specified window, which is</para>
        /// <para>called when the window is resized.  The callback is provided with the size,</para>
        /// <para>in screen coordinates, of the content area of the window.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowsizefun GlfwSetWindowSizeCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowsizefun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowSizeCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowsizefun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowsizefun));
        }

        /// <summary>Sets the close callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the close callback of the specified window, which is</para>
        /// <para>called when the user attempts to close the window, for example by clicking</para>
        /// <para>the close widget in the title bar.</para>
        /// <para>The close flag is set before this callback is called, but you can modify it</para>
        /// <para>at any time with</para>
        /// <para>The close callback is not triggered by</para>
        /// <para>Selecting Quit from the application menu will trigger the</para>
        /// <para>close callback for all windows.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 2.5.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowclosefun GlfwSetWindowCloseCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowclosefun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowCloseCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowclosefun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowclosefun));
        }

        /// <summary>Sets the refresh callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the refresh callback of the specified window, which is</para>
        /// <para>called when the content area of the window needs to be redrawn, for example</para>
        /// <para>if the window has been exposed after having been covered by another window.</para>
        /// <para>On compositing window systems such as Aero, Compiz, Aqua or Wayland, where</para>
        /// <para>the window contents are saved off-screen, this callback may be called only</para>
        /// <para>very infrequently or never at all.</para>
        /// <para>Added in version 2.5.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowrefreshfun GlfwSetWindowRefreshCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowrefreshfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowRefreshCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowrefreshfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowrefreshfun));
        }

        /// <summary>Sets the focus callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the focus callback of the specified window, which is</para>
        /// <para>called when the window gains or loses input focus.</para>
        /// <para>After the focus callback is called for a window that lost input focus,</para>
        /// <para>synthetic key and mouse button release events will be generated for all such</para>
        /// <para>that had been pressed.  For more information, seeand</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowfocusfun GlfwSetWindowFocusCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowfocusfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowFocusCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowfocusfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowfocusfun));
        }

        /// <summary>Sets the iconify callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the iconification callback of the specified window, which</para>
        /// <para>is called when the window is iconified or restored.</para>
        /// <para>The wl_shell protocol has no concept of iconification,</para>
        /// <para>this callback will never be called when using this deprecated protocol.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowiconifyfun GlfwSetWindowIconifyCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowiconifyfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowIconifyCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowiconifyfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowiconifyfun));
        }

        /// <summary>Sets the maximize callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the maximization callback of the specified window, which</para>
        /// <para>is called when the window is maximized or restored.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowmaximizefun GlfwSetWindowMaximizeCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowmaximizefun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowMaximizeCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowmaximizefun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowmaximizefun));
        }

        /// <summary>Sets the framebuffer resize callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the framebuffer resize callback of the specified window,</para>
        /// <para>which is called when the framebuffer of the specified window is resized.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWframebuffersizefun GlfwSetFramebufferSizeCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWframebuffersizefun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetFramebufferSizeCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWframebuffersizefun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWframebuffersizefun));
        }

        /// <summary>Sets the window content scale callback for the specified window.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the window content scale callback of the specified window,</para>
        /// <para>which is called when the content scale of the specified window changes.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindowcontentscalefun GlfwSetWindowContentScaleCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWwindowcontentscalefun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetWindowContentScaleCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWwindowcontentscalefun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWwindowcontentscalefun));
        }

        /// <summary>Processes all pending events.</summary>
        /// <remarks>
        /// <para>This function processes only those events that are already in the event</para>
        /// <para>queue and then returns immediately.  Processing events will cause the window</para>
        /// <para>and input callbacks associated with those events to be called.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](to redraw the contents of</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>Do not assume that callbacks you set will _only_ be called in response to</para>
        /// <para>event processing functions like this one.  While it is necessary to poll for</para>
        /// <para>events, window systems that require GLFW to register callbacks of its own</para>
        /// <para>can pass events to GLFW in response to many window system function calls.</para>
        /// <para>GLFW will pass those events on to the application callbacks before</para>
        /// <para>returning.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwPollEvents()
        {
            __Internal.GlfwPollEvents();
        }

        /// <summary>Waits until events are queued and processes them.</summary>
        /// <remarks>
        /// <para>This function puts the calling thread to sleep until at least one event is</para>
        /// <para>available in the event queue.  Once one or more events are available,</para>
        /// <para>it behaves exactly likei.e. the events in the queue</para>
        /// <para>are processed and the function then returns immediately.  Processing events</para>
        /// <para>will cause the window and input callbacks associated with those events to be</para>
        /// <para>called.</para>
        /// <para>Since not all events are associated with callbacks, this function may return</para>
        /// <para>without a callback having been called even if you are monitoring all</para>
        /// <para>callbacks.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](to redraw the contents of</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>Do not assume that callbacks you set will _only_ be called in response to</para>
        /// <para>event processing functions like this one.  While it is necessary to poll for</para>
        /// <para>events, window systems that require GLFW to register callbacks of its own</para>
        /// <para>can pass events to GLFW in response to many window system function calls.</para>
        /// <para>GLFW will pass those events on to the application callbacks before</para>
        /// <para>returning.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 2.5.</para>
        /// </remarks>
        public static void GlfwWaitEvents()
        {
            __Internal.GlfwWaitEvents();
        }

        /// <summary>Waits with timeout until events are queued and processes them.</summary>
        /// <param name="timeout">The maximum amount of time, in seconds, to wait.</param>
        /// <remarks>
        /// <para>This function puts the calling thread to sleep until at least one event is</para>
        /// <para>available in the event queue, or until the specified timeout is reached.  If</para>
        /// <para>one or more events are available, it behaves exactly likei.e. the events in the queue are processed and the function</para>
        /// <para>then returns immediately.  Processing events will cause the window and input</para>
        /// <para>callbacks associated with those events to be called.</para>
        /// <para>The timeout value must be a positive finite number.</para>
        /// <para>Since not all events are associated with callbacks, this function may return</para>
        /// <para>without a callback having been called even if you are monitoring all</para>
        /// <para>callbacks.</para>
        /// <para>On some platforms, a window move, resize or menu operation will cause event</para>
        /// <para>processing to block.  This is due to how event processing is designed on</para>
        /// <para>those platforms.  You can use the</para>
        /// <para>[window refresh callback](to redraw the contents of</para>
        /// <para>your window when necessary during such operations.</para>
        /// <para>Do not assume that callbacks you set will _only_ be called in response to</para>
        /// <para>event processing functions like this one.  While it is necessary to poll for</para>
        /// <para>events, window systems that require GLFW to register callbacks of its own</para>
        /// <para>can pass events to GLFW in response to many window system function calls.</para>
        /// <para>GLFW will pass those events on to the application callbacks before</para>
        /// <para>returning.</para>
        /// <para>Event processing is not required for joystick input to work.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static void GlfwWaitEventsTimeout(double timeout)
        {
            __Internal.GlfwWaitEventsTimeout(timeout);
        }

        /// <summary>Posts an empty event to the event queue.</summary>
        /// <remarks>
        /// <para>This function posts an empty event from the current thread to the event</para>
        /// <para>queue, causingorto return.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwPostEmptyEvent()
        {
            __Internal.GlfwPostEmptyEvent();
        }

        /// <summary>Returns the value of an input option for the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <param name="mode">
        /// <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or</para>
        /// <para>`GLFW_RAW_MOUSE_MOTION`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the value of an input option for the specified window.</para>
        /// <para>The mode must be one ofor</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static int GlfwGetInputMode(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int mode)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetInputMode(__arg0, mode);
            return __ret;
        }

        /// <summary>Sets an input option for the specified window.</summary>
        /// <param name="window">The window whose input mode to set.</param>
        /// <param name="mode">
        /// <para>One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,</para>
        /// <para>`GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or</para>
        /// <para>`GLFW_RAW_MOUSE_MOTION`.</para>
        /// </param>
        /// <param name="value">The new value of the specified input mode.</param>
        /// <remarks>
        /// <para>This function sets an input mode option for the specified window.  The mode</para>
        /// <para>must be one ofor</para>
        /// <para>If the mode is `GLFW_CURSOR`, the value must be one of the following cursor</para>
        /// <para>modes:</para>
        /// <para>- `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.</para>
        /// <para>- `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the</para>
        /// <para>content area of the window but does not restrict the cursor from leaving.</para>
        /// <para>- `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual</para>
        /// <para>and unlimited cursor movement.  This is useful for implementing for</para>
        /// <para>example 3D camera controls.</para>
        /// <para>If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to</para>
        /// <para>enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are</para>
        /// <para>enabled, a key press will ensure thatreturns `GLFW_PRESS`</para>
        /// <para>the next time it is called even if the key had been released before the</para>
        /// <para>call.  This is useful when you are only interested in whether keys have been</para>
        /// <para>pressed but not when or in which order.</para>
        /// <para>If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either</para>
        /// <para>`GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.</para>
        /// <para>If sticky mouse buttons are enabled, a mouse button press will ensure that</para>
        /// <para>returns `GLFW_PRESS` the next time it is called even</para>
        /// <para>if the mouse button had been released before the call.  This is useful when</para>
        /// <para>you are only interested in whether mouse buttons have been pressed but not</para>
        /// <para>when or in which order.</para>
        /// <para>If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to</para>
        /// <para>enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,</para>
        /// <para>callbacks that receive modifier bits will also have thebit set when the event was generated with Caps Lock on,</para>
        /// <para>and thebit when Num Lock was on.</para>
        /// <para>If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`</para>
        /// <para>to enable raw (unscaled and unaccelerated) mouse motion when the cursor is</para>
        /// <para>disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,</para>
        /// <para>attempting to set this will emitCallto check for support.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.</para>
        /// </remarks>
        public static void GlfwSetInputMode(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int mode, int value)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetInputMode(__arg0, mode, value);
        }

        /// <summary>Returns whether raw mouse motion is supported.</summary>
        /// <returns>
        /// <para>`GLFW_TRUE` if raw mouse motion is supported on the current machine,</para>
        /// <para>or `GLFW_FALSE` otherwise.</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether raw mouse motion is supported on the current</para>
        /// <para>system.  This status does not change after GLFW has been initialized so you</para>
        /// <para>only need to check this once.  If you attempt to enable raw motion on</para>
        /// <para>a system that does not support it,will be emitted.</para>
        /// <para>Raw mouse motion is closer to the actual motion of the mouse across</para>
        /// <para>a surface.  It is not affected by the scaling and acceleration applied to</para>
        /// <para>the motion of the desktop cursor.  That processing is suitable for a cursor</para>
        /// <para>while raw motion is better for controlling for example a 3D camera.  Because</para>
        /// <para>of this, raw mouse motion is only provided when the cursor is disabled.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwRawMouseMotionSupported()
        {
            var __ret = __Internal.GlfwRawMouseMotionSupported();
            return __ret;
        }

        /// <summary>Returns the layout-specific name of the specified printable key.</summary>
        /// <param name="key">The key to query, or `GLFW_KEY_UNKNOWN`.</param>
        /// <param name="scancode">The scancode of the key to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded, layout-specific name of the key, or `NULL`.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the name of the specified printable key, encoded as</para>
        /// <para>UTF-8.  This is typically the character that key would produce without any</para>
        /// <para>modifier keys, intended for displaying key bindings to the user.  For dead</para>
        /// <para>keys, it is typically the diacritic it would add to a character.</para>
        /// <para>__Do not use this function__ for [text input](You will</para>
        /// <para>break text input for many languages even if it happens to work for yours.</para>
        /// <para>If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,</para>
        /// <para>otherwise the scancode is ignored.  If you specify a non-printable key, or</para>
        /// <para>`GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this</para>
        /// <para>function returns `NULL` but does not emit an error.</para>
        /// <para>This behavior allows you to always pass in the arguments in the</para>
        /// <para>[key callback](without modification.</para>
        /// <para>The printable keys are:</para>
        /// <para>- `GLFW_KEY_APOSTROPHE`</para>
        /// <para>- `GLFW_KEY_COMMA`</para>
        /// <para>- `GLFW_KEY_MINUS`</para>
        /// <para>- `GLFW_KEY_PERIOD`</para>
        /// <para>- `GLFW_KEY_SLASH`</para>
        /// <para>- `GLFW_KEY_SEMICOLON`</para>
        /// <para>- `GLFW_KEY_EQUAL`</para>
        /// <para>- `GLFW_KEY_LEFT_BRACKET`</para>
        /// <para>- `GLFW_KEY_RIGHT_BRACKET`</para>
        /// <para>- `GLFW_KEY_BACKSLASH`</para>
        /// <para>- `GLFW_KEY_WORLD_1`</para>
        /// <para>- `GLFW_KEY_WORLD_2`</para>
        /// <para>- `GLFW_KEY_0` to `GLFW_KEY_9`</para>
        /// <para>- `GLFW_KEY_A` to `GLFW_KEY_Z`</para>
        /// <para>- `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`</para>
        /// <para>- `GLFW_KEY_KP_DECIMAL`</para>
        /// <para>- `GLFW_KEY_KP_DIVIDE`</para>
        /// <para>- `GLFW_KEY_KP_MULTIPLY`</para>
        /// <para>- `GLFW_KEY_KP_SUBTRACT`</para>
        /// <para>- `GLFW_KEY_KP_ADD`</para>
        /// <para>- `GLFW_KEY_KP_EQUAL`</para>
        /// <para>Names for printable keys depend on keyboard layout, while names for</para>
        /// <para>non-printable keys are the same across layouts but depend on the application</para>
        /// <para>language and should be localized along with other user interface text.</para>
        /// <para>The contents of the returned string may change when a keyboard</para>
        /// <para>layout change event is received.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static string GlfwGetKeyName(int key, int scancode)
        {
            var __ret = __Internal.GlfwGetKeyName(key, scancode);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns the platform-specific scancode of the specified key.</summary>
        /// <param name="key">Any [named key](</param>
        /// <returns>
        /// <para>The platform-specific scancode for the key, or `-1` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the platform-specific scancode of the specified key.</para>
        /// <para>If the key is `GLFW_KEY_UNKNOWN` or does not exist on the keyboard this</para>
        /// <para>method will return `-1`.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwGetKeyScancode(int key)
        {
            var __ret = __Internal.GlfwGetKeyScancode(key);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the last reported state of a keyboard key for the specified</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="key">
        /// <para>The desired [keyboard key](`GLFW_KEY_UNKNOWN` is</para>
        /// <para>not a valid key for this function.</para>
        /// </param>
        /// <returns>
        /// <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the last state reported for the specified key to the</para>
        /// <para>specified window.  The returned state is one of `GLFW_PRESS` or</para>
        /// <para>`GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to</para>
        /// <para>the key callback.</para>
        /// <para>If theinput mode is enabled, this function returns</para>
        /// <para>`GLFW_PRESS` the first time you call it for a key that was pressed, even if</para>
        /// <para>that key has already been released.</para>
        /// <para>The key functions deal with physical keys, with [key tokens](named after their use on the standard US keyboard layout.  If you want to</para>
        /// <para>input text, use the Unicode character callback instead.</para>
        /// <para>The [modifier key bit masks](are not key tokens and cannot be</para>
        /// <para>used with this function.</para>
        /// <para>__Do not use this function__ to implement [text input](</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static int GlfwGetKey(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int key)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetKey(__arg0, key);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the last reported state of a mouse button for the specified</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="button">The desired [mouse button](</param>
        /// <returns>
        /// <para>One of `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the last state reported for the specified mouse button</para>
        /// <para>to the specified window.  The returned state is one of `GLFW_PRESS` or</para>
        /// <para>`GLFW_RELEASE`.</para>
        /// <para>If theinput mode is enabled, this function</para>
        /// <para>returns `GLFW_PRESS` the first time you call it for a mouse button that was</para>
        /// <para>pressed, even if that mouse button has already been released.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static int GlfwGetMouseButton(global::Utubz.Internal.Native.Glfw.GLFWwindow window, int button)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetMouseButton(__arg0, button);
            return __ret;
        }

        /// <summary>
        /// <para>Retrieves the position of the cursor relative to the content area of</para>
        /// <para>the window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// <para>Where to store the cursor x-coordinate, relative to the</para>
        /// <para>left edge of the content area, or `NULL`.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>Where to store the cursor y-coordinate, relative to the to</para>
        /// <para>top edge of the content area, or `NULL`.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns the position of the cursor, in screen coordinates,</para>
        /// <para>relative to the upper-left corner of the content area of the specified</para>
        /// <para>window.</para>
        /// <para>If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor</para>
        /// <para>position is unbounded and limited only by the minimum and maximum values of</para>
        /// <para>a `double`.</para>
        /// <para>The coordinate can be converted to their integer equivalents with the</para>
        /// <para>`floor` function.  Casting directly to an integer type works for positive</para>
        /// <para>coordinates, but fails for negative ones.</para>
        /// <para>Any or all of the position arguments may be `NULL`.  If an error occurs, all</para>
        /// <para>non-`NULL` position arguments will be set to zero.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetMousePos`.</para>
        /// </remarks>
        public static void GlfwGetCursorPos(global::Utubz.Internal.Native.Glfw.GLFWwindow window, ref double xpos, ref double ypos)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (double* __xpos1 = &xpos)
            {
                var __arg1 = __xpos1;
                fixed (double* __ypos2 = &ypos)
                {
                    var __arg2 = __ypos2;
                    __Internal.GlfwGetCursorPos(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>
        /// <para>Sets the position of the cursor, relative to the content area of the</para>
        /// <para>window.</para>
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        /// <para>The desired x-coordinate, relative to the left edge of the</para>
        /// <para>content area.</para>
        /// </param>
        /// <param name="ypos">
        /// <para>The desired y-coordinate, relative to the top edge of the</para>
        /// <para>content area.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the position, in screen coordinates, of the cursor</para>
        /// <para>relative to the upper-left corner of the content area of the specified</para>
        /// <para>window.  The window must have input focus.  If the window does not have</para>
        /// <para>input focus when this function is called, it fails silently.</para>
        /// <para>__Do not use this function__ to implement things like camera controls.  GLFW</para>
        /// <para>already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the</para>
        /// <para>cursor, transparently re-centers it and provides unconstrained cursor</para>
        /// <para>motion.  Seefor more information.</para>
        /// <para>If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is</para>
        /// <para>unconstrained and limited only by the minimum and maximum values of</para>
        /// <para>a `double`.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function will only work when the cursor mode is</para>
        /// <para>`GLFW_CURSOR_DISABLED`, otherwise it will do nothing.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMousePos`.</para>
        /// </remarks>
        public static void GlfwSetCursorPos(global::Utubz.Internal.Native.Glfw.GLFWwindow window, double xpos, double ypos)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetCursorPos(__arg0, xpos, ypos);
        }

        /// <summary>Creates a custom cursor.</summary>
        /// <param name="image">The desired cursor image.</param>
        /// <param name="xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        /// <param name="yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        /// <returns>
        /// <para>The handle of the created cursor, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The specified image data is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>Creates a new custom cursor image that can be set for a window withThe cursor can be destroyed withAny remaining cursors are destroyed by</para>
        /// <para>The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight</para>
        /// <para>bits per channel with the red channel first.  They are arranged canonically</para>
        /// <para>as packed sequential rows, starting from the top-left corner.</para>
        /// <para>The cursor hotspot is specified in pixels, relative to the upper-left corner</para>
        /// <para>of the cursor image.  Like all other coordinate systems in GLFW, the X-axis</para>
        /// <para>points to the right and the Y-axis points down.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcursor GlfwCreateCursor(global::Utubz.Internal.Native.Glfw.GLFWimage image, int xhot, int yhot)
        {
            var __arg0 = image is null ? __IntPtr.Zero : image.__Instance;
            var __ret = __Internal.GlfwCreateCursor(__arg0, xhot, yhot);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWcursor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Creates a cursor with a standard shape.</summary>
        /// <param name="shape">One of the [standard shapes](</param>
        /// <returns>
        /// <para>A new cursor ready to use or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a cursor with a [standard shape](that can be set for</para>
        /// <para>a window with</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcursor GlfwCreateStandardCursor(int shape)
        {
            var __ret = __Internal.GlfwCreateStandardCursor(shape);
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWcursor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Destroys a cursor.</summary>
        /// <param name="cursor">The cursor object to destroy.</param>
        /// <remarks>
        /// <para>This function destroys a cursor previously created withAny remaining cursors will be destroyed by</para>
        /// <para>If the specified cursor is current for any window, that window will be</para>
        /// <para>reverted to the default cursor.  This does not affect the cursor mode.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must not be called from a callback.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwDestroyCursor(global::Utubz.Internal.Native.Glfw.GLFWcursor cursor)
        {
            var __arg0 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwDestroyCursor(__arg0);
        }

        /// <summary>Sets the cursor for the window.</summary>
        /// <param name="window">The window to set the cursor for.</param>
        /// <param name="cursor">
        /// <para>The cursor to set, or `NULL` to switch back to the default</para>
        /// <para>arrow cursor.</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the cursor image to be used when the cursor is over the</para>
        /// <para>content area of the specified window.  The set cursor will only be visible</para>
        /// <para>when the [cursor mode](of the window is</para>
        /// <para>`GLFW_CURSOR_NORMAL`.</para>
        /// <para>On some platforms, the set cursor may not be visible unless the window also</para>
        /// <para>has input focus.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static void GlfwSetCursor(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWcursor cursor)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            __Internal.GlfwSetCursor(__arg0, __arg1);
        }

        /// <summary>Sets the key callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new key callback, or `NULL` to remove the currently</para>
        /// <para>set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the key callback of the specified window, which is called</para>
        /// <para>when a key is pressed, repeated or released.</para>
        /// <para>The key functions deal with physical keys, with layout independent</para>
        /// <para>[key tokens](named after their values in the standard US keyboard</para>
        /// <para>layout.  If you want to input text, use the</para>
        /// <para>[character callback](instead.</para>
        /// <para>When a window loses input focus, it will generate synthetic key release</para>
        /// <para>events for all pressed keys.  You can tell these events from user-generated</para>
        /// <para>events by the fact that the synthetic ones are generated after the focus</para>
        /// <para>loss event has been processed, i.e. after the</para>
        /// <para>[window focus callback](has been called.</para>
        /// <para>The scancode of a key is specific to that platform or sometimes even to that</para>
        /// <para>machine.  Scancodes are intended to allow users to bind keys that don't have</para>
        /// <para>a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their</para>
        /// <para>state is not saved and so it cannot be queried with</para>
        /// <para>Sometimes GLFW needs to generate synthetic key events, in which case the</para>
        /// <para>scancode may be zero.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWkeyfun GlfwSetKeyCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWkeyfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetKeyCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWkeyfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWkeyfun));
        }

        /// <summary>Sets the Unicode character callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the character callback of the specified window, which is</para>
        /// <para>called when a Unicode character is input.</para>
        /// <para>The character callback is intended for Unicode text input.  As it deals with</para>
        /// <para>characters, it is keyboard layout dependent, whereas the</para>
        /// <para>[key callback](is not.  Characters do not map 1:1</para>
        /// <para>to physical keys, as a key may produce zero, one or more characters.  If you</para>
        /// <para>want to know whether a specific physical key was pressed or released, see</para>
        /// <para>the key callback instead.</para>
        /// <para>The character callback behaves as system text input normally does and will</para>
        /// <para>not be called if modifier keys are held down that would prevent normal text</para>
        /// <para>input on that platform, for example a Super (Command) key on macOS or Alt key</para>
        /// <para>on Windows.</para>
        /// <para>Added in version 2.4.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcharfun GlfwSetCharCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWcharfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetCharCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWcharfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWcharfun));
        }

        /// <summary>Sets the Unicode character with modifiers callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or an</para>
        /// <para>[error](occurred.</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the character with modifiers callback of the specified</para>
        /// <para>window, which is called when a Unicode character is input regardless of what</para>
        /// <para>modifier keys are used.</para>
        /// <para>The character with modifiers callback is intended for implementing custom</para>
        /// <para>Unicode character input.  For regular Unicode text input, see the</para>
        /// <para>[character callback](Like the character</para>
        /// <para>callback, the character with modifiers callback deals with characters and is</para>
        /// <para>keyboard layout dependent.  Characters do not map 1:1 to physical keys, as</para>
        /// <para>a key may produce zero, one or more characters.  If you want to know whether</para>
        /// <para>a specific physical key was pressed or released, see the</para>
        /// <para>[key callback](instead.</para>
        /// <para>Scheduled for removal in version 4.0.</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcharmodsfun GlfwSetCharModsCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWcharmodsfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetCharModsCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWcharmodsfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWcharmodsfun));
        }

        /// <summary>Sets the mouse button callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the mouse button callback of the specified window, which</para>
        /// <para>is called when a mouse button is pressed or released.</para>
        /// <para>When a window loses input focus, it will generate synthetic mouse button</para>
        /// <para>release events for all pressed mouse buttons.  You can tell these events</para>
        /// <para>from user-generated events by the fact that the synthetic ones are generated</para>
        /// <para>after the focus loss event has been processed, i.e. after the</para>
        /// <para>[window focus callback](has been called.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter and return value.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWmousebuttonfun GlfwSetMouseButtonCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWmousebuttonfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetMouseButtonCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWmousebuttonfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWmousebuttonfun));
        }

        /// <summary>Sets the cursor position callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the cursor position callback of the specified window,</para>
        /// <para>which is called when the cursor is moved.  The callback is provided with the</para>
        /// <para>position, in screen coordinates, relative to the upper-left corner of the</para>
        /// <para>content area of the window.</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMousePosCallback`.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcursorposfun GlfwSetCursorPosCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWcursorposfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetCursorPosCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWcursorposfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWcursorposfun));
        }

        /// <summary>Sets the cursor enter/leave callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the cursor boundary crossing callback of the specified</para>
        /// <para>window, which is called when the cursor enters or leaves the content area of</para>
        /// <para>the window.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWcursorenterfun GlfwSetCursorEnterCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWcursorenterfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetCursorEnterCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWcursorenterfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWcursorenterfun));
        }

        /// <summary>Sets the scroll callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new scroll callback, or `NULL` to remove the</para>
        /// <para>currently set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the scroll callback of the specified window, which is</para>
        /// <para>called when a scrolling device is used, such as a mouse wheel or scrolling</para>
        /// <para>area of a touchpad.</para>
        /// <para>The scroll callback receives all scrolling input, like that from a mouse</para>
        /// <para>wheel or a touchpad scrolling area.</para>
        /// <para>Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWscrollfun GlfwSetScrollCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWscrollfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetScrollCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWscrollfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWscrollfun));
        }

        /// <summary>Sets the path drop callback.</summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="callback">
        /// <para>The new file drop callback, or `NULL` to remove the</para>
        /// <para>currently set callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the path drop callback of the specified window, which is</para>
        /// <para>called when one or more dragged paths are dropped on the window.</para>
        /// <para>Because the path array and its strings may have been generated specifically</para>
        /// <para>for that event, they are not guaranteed to be valid after the callback has</para>
        /// <para>returned.  If you wish to use them after the callback returns, you need to</para>
        /// <para>make a deep copy.</para>
        /// <para>File drop is currently unimplemented.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.1.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWdropfun GlfwSetDropCallback(global::Utubz.Internal.Native.Glfw.GLFWwindow window, global::Utubz.Internal.Native.Glfw.GLFWdropfun callback)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetDropCallback(__arg0, __arg1);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWdropfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWdropfun));
        }

        /// <summary>Returns whether the specified joystick is present.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the specified joystick is present.</para>
        /// <para>There is no need to call this function before other functions that accept</para>
        /// <para>a joystick ID, as they all check for presence before performing any other</para>
        /// <para>work.</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetJoystickParam`.</para>
        /// </remarks>
        public static int GlfwJoystickPresent(int jid)
        {
            var __ret = __Internal.GlfwJoystickPresent(jid);
            return __ret;
        }

        /// <summary>Returns the values of all axes of the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <param name="count">
        /// <para>Where to store the number of axis values in the returned</para>
        /// <para>array.  This is set to zero if the joystick is not present or an error</para>
        /// <para>occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of axis values, or `NULL` if the joystick is not present or</para>
        /// <para>an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the values of all axes of the specified joystick.</para>
        /// <para>Each element in the array is a value between -1.0 and 1.0.</para>
        /// <para>If the specified joystick is not present this function will return `NULL`</para>
        /// <para>but will not generate an error.  This can be used instead of first calling</para>
        /// <para>Added in version 3.0.  Replaces `glfwGetJoystickPos`.</para>
        /// </remarks>
        public static float* GlfwGetJoystickAxes(int jid, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GlfwGetJoystickAxes(jid, __arg1);
                return __ret;
            }
        }

        /// <summary>Returns the state of all buttons of the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <param name="count">
        /// <para>Where to store the number of button states in the returned</para>
        /// <para>array.  This is set to zero if the joystick is not present or an error</para>
        /// <para>occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of button states, or `NULL` if the joystick is not present</para>
        /// <para>or an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the state of all buttons of the specified joystick.</para>
        /// <para>Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.</para>
        /// <para>For backward compatibility with earlier versions that did not havethe button array also includes all hats, each</para>
        /// <para>represented as four buttons.  The hats are in the same order as returned by</para>
        /// <para>__glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and</para>
        /// <para>_left_.  To disable these extra buttons, set theinit hint before initialization.</para>
        /// <para>If the specified joystick is not present this function will return `NULL`</para>
        /// <para>but will not generate an error.  This can be used instead of first calling</para>
        /// <para>Added in version 2.2.</para>
        /// <para>Changed to return a dynamic array.</para>
        /// </remarks>
        public static byte* GlfwGetJoystickButtons(int jid, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GlfwGetJoystickButtons(jid, __arg1);
                return __ret;
            }
        }

        /// <summary>Returns the state of all hats of the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <param name="count">
        /// <para>Where to store the number of hat states in the returned</para>
        /// <para>array.  This is set to zero if the joystick is not present or an error</para>
        /// <para>occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of hat states, or `NULL` if the joystick is not present</para>
        /// <para>or an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected, this function is called again for that joystick or the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the state of all hats of the specified joystick.</para>
        /// <para>Each element in the array is one of the following values:</para>
        /// <para>Name                  | Value</para>
        /// <para>----                  | -----</para>
        /// <para>`GLFW_HAT_CENTERED`   | 0</para>
        /// <para>`GLFW_HAT_UP`         | 1</para>
        /// <para>`GLFW_HAT_RIGHT`      | 2</para>
        /// <para>`GLFW_HAT_DOWN`       | 4</para>
        /// <para>`GLFW_HAT_LEFT`       | 8</para>
        /// <para>`GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT`\| `GLFW_HAT_UP`</para>
        /// <para>`GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT`\| `GLFW_HAT_DOWN`</para>
        /// <para>`GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT`\| `GLFW_HAT_UP`</para>
        /// <para>`GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT`\| `GLFW_HAT_DOWN`</para>
        /// <para>The diagonal directions are bitwise combinations of the primary (up, right,</para>
        /// <para>down and left) directions and you can test for these individually by ANDing</para>
        /// <para>it with the corresponding direction.</para>
        /// <para>If the specified joystick is not present this function will return `NULL`</para>
        /// <para>but will not generate an error.  This can be used instead of first calling</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static byte* GlfwGetJoystickHats(int jid, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var __ret = __Internal.GlfwGetJoystickHats(jid, __arg1);
                return __ret;
            }
        }

        /// <summary>Returns the name of the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded name of the joystick, or `NULL` if the joystick</para>
        /// <para>is not present or an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the name, encoded as UTF-8, of the specified joystick.</para>
        /// <para>The returned string is allocated and freed by GLFW.  You should not free it</para>
        /// <para>yourself.</para>
        /// <para>If the specified joystick is not present this function will return `NULL`</para>
        /// <para>but will not generate an error.  This can be used instead of first calling</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetJoystickName(int jid)
        {
            var __ret = __Internal.GlfwGetJoystickName(jid);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns the SDL compatible GUID of the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick</para>
        /// <para>is not present or an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the SDL compatible GUID, as a UTF-8 encoded</para>
        /// <para>hexadecimal string, of the specified joystick.  The returned string is</para>
        /// <para>allocated and freed by GLFW.  You should not free it yourself.</para>
        /// <para>The GUID is what connects a joystick to a gamepad mapping.  A connected</para>
        /// <para>joystick will always have a GUID even if there is no gamepad mapping</para>
        /// <para>assigned to it.</para>
        /// <para>If the specified joystick is not present this function will return `NULL`</para>
        /// <para>but will not generate an error.  This can be used instead of first calling</para>
        /// <para>The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to</para>
        /// <para>uniquely identify the make and model of a joystick but does not identify</para>
        /// <para>a specific unit, e.g. all wired Xbox 360 controllers will have the same</para>
        /// <para>GUID on that platform.  The GUID for a unit may vary between platforms</para>
        /// <para>depending on what hardware information the platform specific APIs provide.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static string GlfwGetJoystickGUID(int jid)
        {
            var __ret = __Internal.GlfwGetJoystickGUID(jid);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Sets the user pointer of the specified joystick.</summary>
        /// <param name="jid">The joystick whose pointer to set.</param>
        /// <param name="pointer">The new value.</param>
        /// <remarks>
        /// <para>This function sets the user-defined pointer of the specified joystick.  The</para>
        /// <para>current value is retained until the joystick is disconnected.  The initial</para>
        /// <para>value is `NULL`.</para>
        /// <para>This function may be called from the joystick callback, even for a joystick</para>
        /// <para>that is being disconnected.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static void GlfwSetJoystickUserPointer(int jid, __IntPtr pointer)
        {
            __Internal.GlfwSetJoystickUserPointer(jid, pointer);
        }

        /// <summary>Returns the user pointer of the specified joystick.</summary>
        /// <param name="jid">The joystick whose pointer to return.</param>
        /// <remarks>
        /// <para>This function returns the current value of the user-defined pointer of the</para>
        /// <para>specified joystick.  The initial value is `NULL`.</para>
        /// <para>This function may be called from the joystick callback, even for a joystick</para>
        /// <para>that is being disconnected.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Access is not</para>
        /// <para>synchronized.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static __IntPtr GlfwGetJoystickUserPointer(int jid)
        {
            var __ret = __Internal.GlfwGetJoystickUserPointer(jid);
            return __ret;
        }

        /// <summary>Returns whether the specified joystick has a gamepad mapping.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if a joystick is both present and has a gamepad mapping,</para>
        /// <para>or `GLFW_FALSE` otherwise.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the specified joystick is both present and has</para>
        /// <para>a gamepad mapping.</para>
        /// <para>If the specified joystick is present but does not have a gamepad mapping</para>
        /// <para>this function will return `GLFW_FALSE` but will not generate an error.  Call</para>
        /// <para>to check if a joystick is present regardless of</para>
        /// <para>whether it has a mapping.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwJoystickIsGamepad(int jid)
        {
            var __ret = __Internal.GlfwJoystickIsGamepad(jid);
            return __ret;
        }

        /// <summary>Sets the joystick configuration callback.</summary>
        /// <param name="callback">
        /// <para>The new callback, or `NULL` to remove the currently set</para>
        /// <para>callback.</para>
        /// </param>
        /// <returns>
        /// <para>The previously set callback, or `NULL` if no callback was set or the</para>
        /// <para>library had not been [initialized](</para>
        /// <para>For more information about the callback parameters, see the</para>
        /// <para>[function pointer type](</para>
        /// <para>Possible errors include</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function sets the joystick configuration callback, or removes the</para>
        /// <para>currently set callback.  This is called when a joystick is connected to or</para>
        /// <para>disconnected from the system.</para>
        /// <para>For joystick connection and disconnection events to be delivered on all</para>
        /// <para>platforms, you need to call one of the [event processing](functions.  Joystick disconnection may also be detected and the callback</para>
        /// <para>called by joystick functions.  The function will then return whatever it</para>
        /// <para>returns if the joystick is not present.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWjoystickfun GlfwSetJoystickCallback(global::Utubz.Internal.Native.Glfw.GLFWjoystickfun callback)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.GlfwSetJoystickCallback(__arg0);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWjoystickfun) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWjoystickfun));
        }

        /// <summary>Adds the specified SDL_GameControllerDB gamepad mappings.</summary>
        /// <param name="string">The string containing the gamepad mappings.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if successful, or `GLFW_FALSE` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function parses the specified ASCII encoded string and updates the</para>
        /// <para>internal list with any gamepad mappings it finds.  This string may</para>
        /// <para>contain either a single gamepad mapping or many mappings separated by</para>
        /// <para>newlines.  The parser supports the full format of the `gamecontrollerdb.txt`</para>
        /// <para>source file including empty lines and comments.</para>
        /// <para>Seefor a description of the format.</para>
        /// <para>If there is already a gamepad mapping for a given GUID in the internal list,</para>
        /// <para>it will be replaced by the one passed to this function.  If the library is</para>
        /// <para>terminated and re-initialized the internal list will revert to the built-in</para>
        /// <para>default.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwUpdateGamepadMappings(string @string)
        {
            var __ret = __Internal.GlfwUpdateGamepadMappings(@string);
            return __ret;
        }

        /// <summary>Returns the human-readable gamepad name for the specified joystick.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <returns>
        /// <para>The UTF-8 encoded name of the gamepad, or `NULL` if the</para>
        /// <para>joystick is not present, does not have a mapping or an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the specified joystick is</para>
        /// <para>disconnected, the gamepad mappings are updated or the library is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the human-readable name of the gamepad from the</para>
        /// <para>gamepad mapping assigned to the specified joystick.</para>
        /// <para>If the specified joystick is not present or does not have a gamepad mapping</para>
        /// <para>this function will return `NULL` but will not generate an error.  Call</para>
        /// <para>to check whether it is present regardless of</para>
        /// <para>whether it has a mapping.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static string GlfwGetGamepadName(int jid)
        {
            var __ret = __Internal.GlfwGetGamepadName(jid);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Retrieves the state of the specified joystick remapped as a gamepad.</summary>
        /// <param name="jid">The [joystick](to query.</param>
        /// <param name="state">The gamepad input state of the joystick.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is</para>
        /// <para>connected, it has no gamepad mapping or an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function retrieves the state of the specified joystick remapped to</para>
        /// <para>an Xbox-like gamepad.</para>
        /// <para>If the specified joystick is not present or does not have a gamepad mapping</para>
        /// <para>this function will return `GLFW_FALSE` but will not generate an error.  Call</para>
        /// <para>to check whether it is present regardless of</para>
        /// <para>whether it has a mapping.</para>
        /// <para>The Guide button may not be available for input as it is often hooked by the</para>
        /// <para>system or the Steam client.</para>
        /// <para>Not all devices have all the buttons or axes provided byUnavailable buttons and axes will always report</para>
        /// <para>`GLFW_RELEASE` and 0.0 respectively.</para>
        /// <para>Added in version 3.3.</para>
        /// </remarks>
        public static int GlfwGetGamepadState(int jid, global::Utubz.Internal.Native.Glfw.GLFWgamepadstate state)
        {
            var __arg1 = state is null ? __IntPtr.Zero : state.__Instance;
            var __ret = __Internal.GlfwGetGamepadState(jid, __arg1);
            return __ret;
        }

        /// <summary>Sets the clipboard to the specified string.</summary>
        /// <param name="window">Deprecated.  Any valid window or `NULL`.</param>
        /// <param name="string">A UTF-8 encoded string.</param>
        /// <remarks>
        /// <para>This function sets the system clipboard to the specified, UTF-8 encoded</para>
        /// <para>string.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The specified string is copied before this function</para>
        /// <para>returns.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwSetClipboardString(global::Utubz.Internal.Native.Glfw.GLFWwindow window, string @string)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSetClipboardString(__arg0, @string);
        }

        /// <summary>Returns the contents of the clipboard as a string.</summary>
        /// <param name="window">Deprecated.  Any valid window or `NULL`.</param>
        /// <returns>
        /// <para>The contents of the clipboard as a UTF-8 encoded string, or `NULL`</para>
        /// <para>if an [error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// <para>The returned string is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is valid until the next call tooror until the library</para>
        /// <para>is terminated.</para>
        /// <para>This function must only be called from the main thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the contents of the system clipboard, if it contains</para>
        /// <para>or is convertible to a UTF-8 encoded string.  If the clipboard is empty or</para>
        /// <para>if its contents cannot be converted, `NULL` is returned and aerror is generated.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static string GlfwGetClipboardString(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GlfwGetClipboardString(__arg0);
            return Utubz.Internal.Native.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        /// <summary>Returns the GLFW time.</summary>
        /// <returns>
        /// <para>The current time, in seconds, or zero if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.  Reading and</para>
        /// <para>writing of the internal base time is not atomic, so it needs to be</para>
        /// <para>externally synchronized with calls to</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current GLFW time, in seconds.  Unless the time</para>
        /// <para>has been set usingit measures time elapsed since GLFW was</para>
        /// <para>initialized.</para>
        /// <para>This function andare helper functions on top ofand</para>
        /// <para>The resolution of the timer is system dependent, but is usually on the order</para>
        /// <para>of a few micro- or nanoseconds.  It uses the highest-resolution monotonic</para>
        /// <para>time source on each supported platform.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static double GlfwGetTime()
        {
            var __ret = __Internal.GlfwGetTime();
            return __ret;
        }

        /// <summary>Sets the GLFW time.</summary>
        /// <param name="time">The new value, in seconds.</param>
        /// <remarks>
        /// <para>This function sets the current GLFW time, in seconds.  The value must be</para>
        /// <para>a positive finite number less than or equal to 18446744073.0, which is</para>
        /// <para>approximately 584.5 years.</para>
        /// <para>This function andare helper functions on top ofand</para>
        /// <para>Possible errors includeand</para>
        /// <para>The upper limit of GLFW time is calculated as</para>
        /// <para>floor((264- 1) / 109) and is due to implementations</para>
        /// <para>storing nanoseconds in 64 bits.  The limit may be increased in the future.</para>
        /// <para>This function may be called from any thread.  Reading and</para>
        /// <para>writing of the internal base time is not atomic, so it needs to be</para>
        /// <para>externally synchronized with calls to</para>
        /// <para>Added in version 2.2.</para>
        /// </remarks>
        public static void GlfwSetTime(double time)
        {
            __Internal.GlfwSetTime(time);
        }

        /// <summary>Returns the current value of the raw timer.</summary>
        /// <returns>
        /// <para>The value of the timer, or zero if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the current value of the raw timer, measured in</para>
        /// <para>1&#160;/&#160;frequency seconds.  To get the frequency, call</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static ulong GlfwGetTimerValue()
        {
            var __ret = __Internal.GlfwGetTimerValue();
            return __ret;
        }

        /// <summary>Returns the frequency, in Hz, of the raw timer.</summary>
        /// <returns>
        /// <para>The frequency of the timer, in Hz, or zero if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the frequency, in Hz, of the raw timer.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static ulong GlfwGetTimerFrequency()
        {
            var __ret = __Internal.GlfwGetTimerFrequency();
            return __ret;
        }

        /// <summary>
        /// <para>Makes the context of the specified window current for the calling</para>
        /// <para>thread.</para>
        /// </summary>
        /// <param name="window">
        /// <para>The window whose context to make current, or `NULL` to</para>
        /// <para>detach the current context.</para>
        /// </param>
        /// <remarks>
        /// <para>This function makes the OpenGL or OpenGL ES context of the specified window</para>
        /// <para>current on the calling thread.  A context must only be made current on</para>
        /// <para>a single thread at a time and each thread can have only a single current</para>
        /// <para>context at a time.</para>
        /// <para>When moving a context between threads, you must make it non-current on the</para>
        /// <para>old thread before making it current on the new one.</para>
        /// <para>By default, making a context non-current implicitly forces a pipeline flush.</para>
        /// <para>On machines that support `GL_KHR_context_flush_control`, you can control</para>
        /// <para>whether a context performs this flush by setting the</para>
        /// <para>[GLFW_CONTEXT_RELEASE_BEHAVIOR](hint.</para>
        /// <para>The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        /// <para>a window without a context will generate aerror.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static void GlfwMakeContextCurrent(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwMakeContextCurrent(__arg0);
        }

        /// <summary>Returns the window whose context is current on the calling thread.</summary>
        /// <returns>
        /// <para>The window whose context is current, or `NULL` if no window's</para>
        /// <para>context is current.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the window whose OpenGL or OpenGL ES context is</para>
        /// <para>current on the calling thread.</para>
        /// <para>Added in version 3.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWwindow GlfwGetCurrentContext()
        {
            var __ret = __Internal.GlfwGetCurrentContext();
            var __result0 = global::Utubz.Internal.Native.Glfw.GLFWwindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Swaps the front and back buffers of the specified window.</summary>
        /// <param name="window">The window whose buffers to swap.</param>
        /// <remarks>
        /// <para>This function swaps the front and back buffers of the specified window when</para>
        /// <para>rendering with OpenGL or OpenGL ES.  If the swap interval is greater than</para>
        /// <para>zero, the GPU driver waits the specified number of screen updates before</para>
        /// <para>swapping the buffers.</para>
        /// <para>The specified window must have an OpenGL or OpenGL ES context.  Specifying</para>
        /// <para>a window without a context will generate aerror.</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see `vkQueuePresentKHR` instead.</para>
        /// <para>Possible errors includeand</para>
        /// <para>__EGL:__ The context of the specified window must be current on the</para>
        /// <para>calling thread.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 1.0.</para>
        /// <para>Added window handle parameter.</para>
        /// </remarks>
        public static void GlfwSwapBuffers(global::Utubz.Internal.Native.Glfw.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GlfwSwapBuffers(__arg0);
        }

        /// <summary>Sets the swap interval for the current context.</summary>
        /// <param name="interval">
        /// <para>The minimum number of screen updates to wait for</para>
        /// <para>until the buffers are swapped by</para>
        /// </param>
        /// <remarks>
        /// <para>This function sets the swap interval for the current OpenGL or OpenGL ES</para>
        /// <para>context, i.e. the number of screen updates to wait from the timewas called before swapping the buffers and returning.  This</para>
        /// <para>is sometimes called _vertical synchronization_, _vertical retrace</para>
        /// <para>synchronization_ or just _vsync_.</para>
        /// <para>A context that supports either of the `WGL_EXT_swap_control_tear` and</para>
        /// <para>`GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap</para>
        /// <para>intervals, which allows the driver to swap immediately even if a frame</para>
        /// <para>arrives a little bit late.  You can check for these extensions with</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause aerror.</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see the present mode of your swapchain instead.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function is not called during context creation, leaving the</para>
        /// <para>swap interval set to whatever is the default on that platform.  This is done</para>
        /// <para>because some swap interval extensions used by GLFW do not allow the swap</para>
        /// <para>interval to be reset to zero once it has been set to a non-zero value.</para>
        /// <para>Some GPU drivers do not honor the requested swap interval, either</para>
        /// <para>because of a user setting that overrides the application's request or due to</para>
        /// <para>bugs in the driver.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static void GlfwSwapInterval(int interval)
        {
            __Internal.GlfwSwapInterval(interval);
        }

        /// <summary>Returns whether the specified extension is available.</summary>
        /// <param name="extension">The ASCII encoded name of the extension.</param>
        /// <returns>
        /// <para>`GLFW_TRUE` if the extension is available, or `GLFW_FALSE`</para>
        /// <para>otherwise.</para>
        /// <para>Possible errors includeand</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the specified</para>
        /// <para>[API extension](is supported by the current OpenGL or</para>
        /// <para>OpenGL ES context.  It searches both for client API extension and context</para>
        /// <para>creation API extensions.</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause aerror.</para>
        /// <para>As this functions retrieves and searches one or more extension strings each</para>
        /// <para>call, it is recommended that you cache its results if it is going to be used</para>
        /// <para>frequently.  The extension strings will not change during the lifetime of</para>
        /// <para>a context, so there is no danger in doing this.</para>
        /// <para>This function does not apply to Vulkan.  If you are using Vulkan, see`vkEnumerateInstanceExtensionProperties`</para>
        /// <para>and `vkEnumerateDeviceExtensionProperties` instead.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static int GlfwExtensionSupported(string extension)
        {
            var __ret = __Internal.GlfwExtensionSupported(extension);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the address of the specified function for the current</para>
        /// <para>context.</para>
        /// </summary>
        /// <param name="procname">The ASCII encoded name of the function.</param>
        /// <returns>
        /// <para>The address of the function, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns the address of the specified OpenGL or OpenGL ES</para>
        /// <para>[core or extension function](if it is supported</para>
        /// <para>by the current context.</para>
        /// <para>A context must be current on the calling thread.  Calling this function</para>
        /// <para>without a current context will cause aerror.</para>
        /// <para>This function does not apply to Vulkan.  If you are rendering with Vulkan,</para>
        /// <para>see`vkGetInstanceProcAddr` and</para>
        /// <para>`vkGetDeviceProcAddr` instead.</para>
        /// <para>The address of a given function is not guaranteed to be the same</para>
        /// <para>between contexts.</para>
        /// <para>This function may return a non-`NULL` address despite the</para>
        /// <para>associated version or extension not being available.  Always check the</para>
        /// <para>context version or extension string first.</para>
        /// <para>The returned function pointer is valid until the context</para>
        /// <para>is destroyed or the library is terminated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 1.0.</para>
        /// </remarks>
        public static global::Utubz.Internal.Native.Glfw.GLFWglproc GlfwGetProcAddress(string procname)
        {
            var __ret = __Internal.GlfwGetProcAddress(procname);
            var __ptr0 = __ret;
            return __ptr0 == IntPtr.Zero? null : (global::Utubz.Internal.Native.Glfw.GLFWglproc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Utubz.Internal.Native.Glfw.GLFWglproc));
        }

        /// <summary>Returns whether the Vulkan loader and an ICD have been found.</summary>
        /// <returns>
        /// <para>`GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`</para>
        /// <para>otherwise.</para>
        /// <para>Possible errors include</para>
        /// <para>This function may be called from any thread.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns whether the Vulkan loader and any minimally functional</para>
        /// <para>ICD have been found.</para>
        /// <para>The availability of a Vulkan loader and even an ICD does not by itself guarantee that</para>
        /// <para>surface creation or even instance creation is possible.  Callto check whether the extensions necessary for Vulkan</para>
        /// <para>surface creation are available andto</para>
        /// <para>check whether a queue family of a physical device supports image presentation.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static int GlfwVulkanSupported()
        {
            var __ret = __Internal.GlfwVulkanSupported();
            return __ret;
        }

        /// <summary>Returns the Vulkan instance extensions required by GLFW.</summary>
        /// <param name="count">
        /// <para>Where to store the number of extensions in the returned</para>
        /// <para>array.  This is set to zero if an error occurred.</para>
        /// </param>
        /// <returns>
        /// <para>An array of ASCII encoded extension names, or `NULL` if an</para>
        /// <para>[error](occurred.</para>
        /// <para>Possible errors includeand</para>
        /// </returns>
        /// <remarks>
        /// <para>This function returns an array of names of Vulkan instance extensions required</para>
        /// <para>by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the</para>
        /// <para>list will always contain `VK_KHR_surface`, so if you don't require any</para>
        /// <para>additional extensions you can pass this list directly to the</para>
        /// <para>`VkInstanceCreateInfo` struct.</para>
        /// <para>If Vulkan is not available on the machine, this function returns `NULL` and</para>
        /// <para>generates aerror.  Callto check whether Vulkan is at least minimally available.</para>
        /// <para>If Vulkan is available but no set of extensions allowing window surface</para>
        /// <para>creation was found, this function returns `NULL`.  You may still use Vulkan</para>
        /// <para>for off-screen rendering and compute work.</para>
        /// <para>Additional extensions may be required by future versions of GLFW.</para>
        /// <para>You should check if any extensions you wish to enable are already in the</para>
        /// <para>returned array, as it is an error to specify an extension more than once in</para>
        /// <para>the `VkInstanceCreateInfo` struct.</para>
        /// <para>GLFW currently supports both the `VK_MVK_macos_surface` and</para>
        /// <para>the newer `VK_EXT_metal_surface` extensions.</para>
        /// <para>The returned array is allocated and freed by GLFW.  You</para>
        /// <para>should not free it yourself.  It is guaranteed to be valid only until the</para>
        /// <para>library is terminated.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Added in version 3.2.</para>
        /// </remarks>
        public static sbyte** GlfwGetRequiredInstanceExtensions(ref uint count)
        {
            fixed (uint* __count0 = &count)
            {
                var __arg0 = __count0;
                var __ret = __Internal.GlfwGetRequiredInstanceExtensions(__arg0);
                return __ret;
            }
        }
    }
}
