// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Utubz.Internal.Native.Bass
{
    internal enum BASS_FX_BFX
    {
        BASS_FX_BFX_ROTATE = 65536,
        BASS_FX_BFX_ECHO = 65537,
        BASS_FX_BFX_FLANGER = 65538,
        BASS_FX_BFX_VOLUME = 65539,
        BASS_FX_BFX_PEAKEQ = 65540,
        BASS_FX_BFX_REVERB = 65541,
        BASS_FX_BFX_LPF = 65542,
        BASS_FX_BFX_MIX = 65543,
        BASS_FX_BFX_DAMP = 65544,
        BASS_FX_BFX_AUTOWAH = 65545,
        BASS_FX_BFX_ECHO2 = 65546,
        BASS_FX_BFX_PHASER = 65547,
        BASS_FX_BFX_ECHO3 = 65548,
        BASS_FX_BFX_CHORUS = 65549,
        BASS_FX_BFX_APF = 65550,
        BASS_FX_BFX_COMPRESSOR = 65551,
        BASS_FX_BFX_DISTORTION = 65552,
        BASS_FX_BFX_COMPRESSOR2 = 65553,
        BASS_FX_BFX_VOLUME_ENV = 65554,
        BASS_FX_BFX_BQF = 65555,
        BASS_FX_BFX_ECHO4 = 65556,
        BASS_FX_BFX_PITCHSHIFT = 65557,
        BASS_FX_BFX_FREEVERB = 65558
    }

    internal enum BASS_BFX_BQF_enum
    {
        BASS_BFX_BQF_LOWPASS = 0,
        BASS_BFX_BQF_HIGHPASS = 1,
        BASS_BFX_BQF_BANDPASS = 2,
        BASS_BFX_BQF_BANDPASS_Q = 3,
        BASS_BFX_BQF_NOTCH = 4,
        BASS_BFX_BQF_ALLPASS = 5,
        BASS_BFX_BQF_PEAKINGEQ = 6,
        BASS_BFX_BQF_LOWSHELF = 7,
        BASS_BFX_BQF_HIGHSHELF = 8
    }

    internal enum BASS_ATTRIB_TEMPO
    {
        BASS_ATTRIB_TEMPO = 65536,
        BASS_ATTRIB_TEMPO_PITCH = 65537,
        BASS_ATTRIB_TEMPO_FREQ = 65538
    }

    internal enum BASS_ATTRIB_TEMPO_OPTION
    {
        BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER = 65552,
        BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH = 65553,
        BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO = 65554,
        BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS = 65555,
        BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS = 65556,
        BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS = 65557,
        BASS_ATTRIB_TEMPO_OPTION_PREVENT_CLICK = 65558
    }

    internal enum BASS_FX_BPM_TRAN
    {
        BASS_FX_BPM_TRAN_X2 = 0,
        BASS_FX_BPM_TRAN_2FREQ = 1,
        BASS_FX_BPM_TRAN_FREQ2 = 2,
        BASS_FX_BPM_TRAN_2PERCENT = 3,
        BASS_FX_BPM_TRAN_PERCENT2 = 4
    }

    internal unsafe partial class BASS_BFX_ROTATE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float fRate;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ROTATE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ROTATE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ROTATE(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ROTATE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ROTATE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ROTATE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ROTATE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ROTATE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ROTATE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ROTATE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ROTATE(global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ROTATE.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FRate
        {
            get
            {
                return ((__Internal*)__Instance)->fRate;
            }

            set
            {
                ((__Internal*)__Instance)->fRate = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_ECHO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float fLevel;
            internal int lDelay;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ECHO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ECHO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ECHO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ECHO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ECHO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ECHO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ECHO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ECHO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ECHO(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fLevel;
            }

            set
            {
                ((__Internal*)__Instance)->fLevel = value;
            }
        }

        public int LDelay
        {
            get
            {
                return ((__Internal*)__Instance)->lDelay;
            }

            set
            {
                ((__Internal*)__Instance)->lDelay = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_FLANGER : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float fWetDry;
            internal float fSpeed;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_FLANGER@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_FLANGER __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_FLANGER(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_FLANGER __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_FLANGER)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_FLANGER __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_FLANGER(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_FLANGER(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_FLANGER(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_FLANGER()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_FLANGER(global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_FLANGER.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FWetDry
        {
            get
            {
                return ((__Internal*)__Instance)->fWetDry;
            }

            set
            {
                ((__Internal*)__Instance)->fWetDry = value;
            }
        }

        public float FSpeed
        {
            get
            {
                return ((__Internal*)__Instance)->fSpeed;
            }

            set
            {
                ((__Internal*)__Instance)->fSpeed = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_VOLUME : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int lChannel;
            internal float fVolume;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_VOLUME@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_VOLUME __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_VOLUME(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_VOLUME __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_VOLUME)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_VOLUME __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_VOLUME(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_VOLUME(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_VOLUME(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_VOLUME()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_VOLUME(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }

        public float FVolume
        {
            get
            {
                return ((__Internal*)__Instance)->fVolume;
            }

            set
            {
                ((__Internal*)__Instance)->fVolume = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_PEAKEQ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int lBand;
            internal float fBandwidth;
            internal float fQ;
            internal float fCenter;
            internal float fGain;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_PEAKEQ@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_PEAKEQ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_PEAKEQ(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_PEAKEQ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_PEAKEQ)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_PEAKEQ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_PEAKEQ(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_PEAKEQ(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_PEAKEQ(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_PEAKEQ()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_PEAKEQ(global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_PEAKEQ.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LBand
        {
            get
            {
                return ((__Internal*)__Instance)->lBand;
            }

            set
            {
                ((__Internal*)__Instance)->lBand = value;
            }
        }

        public float FBandwidth
        {
            get
            {
                return ((__Internal*)__Instance)->fBandwidth;
            }

            set
            {
                ((__Internal*)__Instance)->fBandwidth = value;
            }
        }

        public float FQ
        {
            get
            {
                return ((__Internal*)__Instance)->fQ;
            }

            set
            {
                ((__Internal*)__Instance)->fQ = value;
            }
        }

        public float FCenter
        {
            get
            {
                return ((__Internal*)__Instance)->fCenter;
            }

            set
            {
                ((__Internal*)__Instance)->fCenter = value;
            }
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_REVERB : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float fLevel;
            internal int lDelay;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_REVERB@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_REVERB __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_REVERB(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_REVERB __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_REVERB)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_REVERB __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_REVERB(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_REVERB(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_REVERB(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_REVERB()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_REVERB(global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_REVERB.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fLevel;
            }

            set
            {
                ((__Internal*)__Instance)->fLevel = value;
            }
        }

        public int LDelay
        {
            get
            {
                return ((__Internal*)__Instance)->lDelay;
            }

            set
            {
                ((__Internal*)__Instance)->lDelay = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_LPF : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float fResonance;
            internal float fCutOffFreq;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_LPF@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_LPF> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_LPF>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_LPF __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_LPF(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_LPF __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_LPF)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_LPF __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_LPF(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_LPF(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_LPF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_LPF()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_LPF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_LPF(global::Utubz.Internal.Native.Bass.BASS_BFX_LPF __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_LPF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_LPF.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_LPF.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FResonance
        {
            get
            {
                return ((__Internal*)__Instance)->fResonance;
            }

            set
            {
                ((__Internal*)__Instance)->fResonance = value;
            }
        }

        public float FCutOffFreq
        {
            get
            {
                return ((__Internal*)__Instance)->fCutOffFreq;
            }

            set
            {
                ((__Internal*)__Instance)->fCutOffFreq = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_MIX : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_MIX@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_MIX> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_MIX>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_MIX __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_MIX(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_MIX __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_MIX)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_MIX __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_MIX(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_MIX(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_MIX(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_MIX()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_MIX.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_MIX(global::Utubz.Internal.Native.Bass.BASS_BFX_MIX __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_MIX.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_MIX.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_MIX.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int* LChannel
        {
            get
            {
                return (int*)((__Internal*)__Instance)->lChannel;
            }
        }
    }

    internal unsafe partial class BASS_BFX_DAMP : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float fTarget;
            internal float fQuiet;
            internal float fRate;
            internal float fGain;
            internal float fDelay;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_DAMP@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_DAMP __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_DAMP(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_DAMP __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_DAMP)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_DAMP __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_DAMP(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_DAMP(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_DAMP(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_DAMP()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_DAMP(global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_DAMP.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FTarget
        {
            get
            {
                return ((__Internal*)__Instance)->fTarget;
            }

            set
            {
                ((__Internal*)__Instance)->fTarget = value;
            }
        }

        public float FQuiet
        {
            get
            {
                return ((__Internal*)__Instance)->fQuiet;
            }

            set
            {
                ((__Internal*)__Instance)->fQuiet = value;
            }
        }

        public float FRate
        {
            get
            {
                return ((__Internal*)__Instance)->fRate;
            }

            set
            {
                ((__Internal*)__Instance)->fRate = value;
            }
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_AUTOWAH : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fRate;
            internal float fRange;
            internal float fFreq;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_AUTOWAH@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_AUTOWAH __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_AUTOWAH(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_AUTOWAH __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_AUTOWAH)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_AUTOWAH __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_AUTOWAH(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_AUTOWAH(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_AUTOWAH(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_AUTOWAH()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_AUTOWAH(global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_AUTOWAH.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FRate
        {
            get
            {
                return ((__Internal*)__Instance)->fRate;
            }

            set
            {
                ((__Internal*)__Instance)->fRate = value;
            }
        }

        public float FRange
        {
            get
            {
                return ((__Internal*)__Instance)->fRange;
            }

            set
            {
                ((__Internal*)__Instance)->fRange = value;
            }
        }

        public float FFreq
        {
            get
            {
                return ((__Internal*)__Instance)->fFreq;
            }

            set
            {
                ((__Internal*)__Instance)->fFreq = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_ECHO2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fDelay;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ECHO2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ECHO2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO2(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ECHO2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ECHO2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ECHO2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ECHO2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ECHO2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ECHO2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ECHO2(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2 __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO2.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_PHASER : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fRate;
            internal float fRange;
            internal float fFreq;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_PHASER@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_PHASER __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_PHASER(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_PHASER __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_PHASER)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_PHASER __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_PHASER(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_PHASER(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_PHASER(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_PHASER()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_PHASER(global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_PHASER.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FRate
        {
            get
            {
                return ((__Internal*)__Instance)->fRate;
            }

            set
            {
                ((__Internal*)__Instance)->fRate = value;
            }
        }

        public float FRange
        {
            get
            {
                return ((__Internal*)__Instance)->fRange;
            }

            set
            {
                ((__Internal*)__Instance)->fRange = value;
            }
        }

        public float FFreq
        {
            get
            {
                return ((__Internal*)__Instance)->fFreq;
            }

            set
            {
                ((__Internal*)__Instance)->fFreq = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_ECHO3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fDelay;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ECHO3@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ECHO3 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO3(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ECHO3 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ECHO3)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ECHO3 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO3(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ECHO3(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ECHO3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ECHO3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ECHO3(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3 __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO3.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_CHORUS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fMinSweep;
            internal float fMaxSweep;
            internal float fRate;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_CHORUS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_CHORUS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_CHORUS(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_CHORUS __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_CHORUS)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_CHORUS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_CHORUS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_CHORUS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_CHORUS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_CHORUS()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_CHORUS(global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_CHORUS.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FMinSweep
        {
            get
            {
                return ((__Internal*)__Instance)->fMinSweep;
            }

            set
            {
                ((__Internal*)__Instance)->fMinSweep = value;
            }
        }

        public float FMaxSweep
        {
            get
            {
                return ((__Internal*)__Instance)->fMaxSweep;
            }

            set
            {
                ((__Internal*)__Instance)->fMaxSweep = value;
            }
        }

        public float FRate
        {
            get
            {
                return ((__Internal*)__Instance)->fRate;
            }

            set
            {
                ((__Internal*)__Instance)->fRate = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_APF : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float fGain;
            internal float fDelay;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_APF@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_APF> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_APF>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_APF __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_APF(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_APF __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_APF)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_APF __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_APF(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_APF(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_APF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_APF()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_APF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_APF(global::Utubz.Internal.Native.Bass.BASS_BFX_APF __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_APF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_APF.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_APF.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_COMPRESSOR : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float fThreshold;
            internal float fAttacktime;
            internal float fReleasetime;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_COMPRESSOR@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_COMPRESSOR __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_COMPRESSOR(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_COMPRESSOR __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_COMPRESSOR)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_COMPRESSOR __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_COMPRESSOR(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_COMPRESSOR(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_COMPRESSOR(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_COMPRESSOR()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_COMPRESSOR(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->fThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->fThreshold = value;
            }
        }

        public float FAttacktime
        {
            get
            {
                return ((__Internal*)__Instance)->fAttacktime;
            }

            set
            {
                ((__Internal*)__Instance)->fAttacktime = value;
            }
        }

        public float FReleasetime
        {
            get
            {
                return ((__Internal*)__Instance)->fReleasetime;
            }

            set
            {
                ((__Internal*)__Instance)->fReleasetime = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_DISTORTION : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float fDrive;
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fVolume;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_DISTORTION@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_DISTORTION __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_DISTORTION(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_DISTORTION __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_DISTORTION)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_DISTORTION __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_DISTORTION(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_DISTORTION(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_DISTORTION(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_DISTORTION()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_DISTORTION(global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_DISTORTION.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDrive
        {
            get
            {
                return ((__Internal*)__Instance)->fDrive;
            }

            set
            {
                ((__Internal*)__Instance)->fDrive = value;
            }
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FVolume
        {
            get
            {
                return ((__Internal*)__Instance)->fVolume;
            }

            set
            {
                ((__Internal*)__Instance)->fVolume = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_COMPRESSOR2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float fGain;
            internal float fThreshold;
            internal float fRatio;
            internal float fAttack;
            internal float fRelease;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_COMPRESSOR2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_COMPRESSOR2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_COMPRESSOR2(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_COMPRESSOR2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_COMPRESSOR2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_COMPRESSOR2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_COMPRESSOR2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_COMPRESSOR2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_COMPRESSOR2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_COMPRESSOR2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_COMPRESSOR2(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2 __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_COMPRESSOR2.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->fThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->fThreshold = value;
            }
        }

        public float FRatio
        {
            get
            {
                return ((__Internal*)__Instance)->fRatio;
            }

            set
            {
                ((__Internal*)__Instance)->fRatio = value;
            }
        }

        public float FAttack
        {
            get
            {
                return ((__Internal*)__Instance)->fAttack;
            }

            set
            {
                ((__Internal*)__Instance)->fAttack = value;
            }
        }

        public float FRelease
        {
            get
            {
                return ((__Internal*)__Instance)->fRelease;
            }

            set
            {
                ((__Internal*)__Instance)->fRelease = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_VOLUME_ENV : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int lChannel;
            internal int lNodeCount;
            internal __IntPtr pNodes;
            internal int bFollow;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_VOLUME_ENV@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_VOLUME_ENV __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_VOLUME_ENV(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_VOLUME_ENV __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_VOLUME_ENV)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_VOLUME_ENV __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_VOLUME_ENV(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_VOLUME_ENV(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_VOLUME_ENV(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_VOLUME_ENV()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_VOLUME_ENV(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_VOLUME_ENV.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }

        public int LNodeCount
        {
            get
            {
                return ((__Internal*)__Instance)->lNodeCount;
            }

            set
            {
                ((__Internal*)__Instance)->lNodeCount = value;
            }
        }

        public global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE PNodes
        {
            get
            {
                var __result0 = global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE.__GetOrCreateInstance(((__Internal*)__Instance)->pNodes, false);
                return __result0;
            }
        }

        public int BFollow
        {
            get
            {
                return ((__Internal*)__Instance)->bFollow;
            }

            set
            {
                ((__Internal*)__Instance)->bFollow = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_ENV_NODE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12, Pack = 4)]
        public partial struct __Internal
        {
            internal double pos;
            internal float val;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ENV_NODE@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ENV_NODE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ENV_NODE(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ENV_NODE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ENV_NODE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ENV_NODE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ENV_NODE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ENV_NODE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ENV_NODE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ENV_NODE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ENV_NODE(global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ENV_NODE.__Internal*)_0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public double Pos
        {
            get
            {
                return ((__Internal*)__Instance)->pos;
            }

            set
            {
                ((__Internal*)__Instance)->pos = value;
            }
        }

        public float Val
        {
            get
            {
                return ((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_BQF : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int lFilter;
            internal float fCenter;
            internal float fGain;
            internal float fBandwidth;
            internal float fQ;
            internal float fS;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_BQF@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_BQF> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_BQF>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_BQF __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_BQF(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_BQF __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_BQF)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_BQF __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_BQF(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_BQF(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_BQF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_BQF()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_BQF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_BQF(global::Utubz.Internal.Native.Bass.BASS_BFX_BQF __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_BQF.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_BQF.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_BQF.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LFilter
        {
            get
            {
                return ((__Internal*)__Instance)->lFilter;
            }

            set
            {
                ((__Internal*)__Instance)->lFilter = value;
            }
        }

        public float FCenter
        {
            get
            {
                return ((__Internal*)__Instance)->fCenter;
            }

            set
            {
                ((__Internal*)__Instance)->fCenter = value;
            }
        }

        public float FGain
        {
            get
            {
                return ((__Internal*)__Instance)->fGain;
            }

            set
            {
                ((__Internal*)__Instance)->fGain = value;
            }
        }

        public float FBandwidth
        {
            get
            {
                return ((__Internal*)__Instance)->fBandwidth;
            }

            set
            {
                ((__Internal*)__Instance)->fBandwidth = value;
            }
        }

        public float FQ
        {
            get
            {
                return ((__Internal*)__Instance)->fQ;
            }

            set
            {
                ((__Internal*)__Instance)->fQ = value;
            }
        }

        public float FS
        {
            get
            {
                return ((__Internal*)__Instance)->fS;
            }

            set
            {
                ((__Internal*)__Instance)->fS = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_ECHO4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fFeedback;
            internal float fDelay;
            internal int bStereo;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_ECHO4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_ECHO4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO4(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_ECHO4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_ECHO4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_ECHO4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_ECHO4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_ECHO4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_ECHO4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_ECHO4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_ECHO4(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4 __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_ECHO4.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FFeedback
        {
            get
            {
                return ((__Internal*)__Instance)->fFeedback;
            }

            set
            {
                ((__Internal*)__Instance)->fFeedback = value;
            }
        }

        public float FDelay
        {
            get
            {
                return ((__Internal*)__Instance)->fDelay;
            }

            set
            {
                ((__Internal*)__Instance)->fDelay = value;
            }
        }

        public int BStereo
        {
            get
            {
                return ((__Internal*)__Instance)->bStereo;
            }

            set
            {
                ((__Internal*)__Instance)->bStereo = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_PITCHSHIFT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal float fPitchShift;
            internal float fSemitones;
            internal int lFFTsize;
            internal int lOsamp;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_PITCHSHIFT@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_PITCHSHIFT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_PITCHSHIFT(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_PITCHSHIFT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_PITCHSHIFT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_PITCHSHIFT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_PITCHSHIFT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_PITCHSHIFT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_PITCHSHIFT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_PITCHSHIFT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_PITCHSHIFT(global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_PITCHSHIFT.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FPitchShift
        {
            get
            {
                return ((__Internal*)__Instance)->fPitchShift;
            }

            set
            {
                ((__Internal*)__Instance)->fPitchShift = value;
            }
        }

        public float FSemitones
        {
            get
            {
                return ((__Internal*)__Instance)->fSemitones;
            }

            set
            {
                ((__Internal*)__Instance)->fSemitones = value;
            }
        }

        public int LFFTsize
        {
            get
            {
                return ((__Internal*)__Instance)->lFFTsize;
            }

            set
            {
                ((__Internal*)__Instance)->lFFTsize = value;
            }
        }

        public int LOsamp
        {
            get
            {
                return ((__Internal*)__Instance)->lOsamp;
            }

            set
            {
                ((__Internal*)__Instance)->lOsamp = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class BASS_BFX_FREEVERB : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal float fDryMix;
            internal float fWetMix;
            internal float fRoomSize;
            internal float fDamp;
            internal float fWidth;
            internal uint lMode;
            internal int lChannel;

            [SuppressUnmanagedCodeSecurity, DllImport("BassFx", EntryPoint = "??0BASS_BFX_FREEVERB@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB>();

        protected bool __ownsNativeInstance;

        internal static BASS_BFX_FREEVERB __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BASS_BFX_FREEVERB(native.ToPointer(), skipVTables);
        }

        internal static BASS_BFX_FREEVERB __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BASS_BFX_FREEVERB)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BASS_BFX_FREEVERB __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BASS_BFX_FREEVERB(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*)ret = native;
            return ret.ToPointer();
        }

        private BASS_BFX_FREEVERB(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BASS_BFX_FREEVERB(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BASS_BFX_FREEVERB()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public BASS_BFX_FREEVERB(global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB.__Internal*)__Instance) = *((global::Utubz.Internal.Native.Bass.BASS_BFX_FREEVERB.__Internal*)__0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FDryMix
        {
            get
            {
                return ((__Internal*)__Instance)->fDryMix;
            }

            set
            {
                ((__Internal*)__Instance)->fDryMix = value;
            }
        }

        public float FWetMix
        {
            get
            {
                return ((__Internal*)__Instance)->fWetMix;
            }

            set
            {
                ((__Internal*)__Instance)->fWetMix = value;
            }
        }

        public float FRoomSize
        {
            get
            {
                return ((__Internal*)__Instance)->fRoomSize;
            }

            set
            {
                ((__Internal*)__Instance)->fRoomSize = value;
            }
        }

        public float FDamp
        {
            get
            {
                return ((__Internal*)__Instance)->fDamp;
            }

            set
            {
                ((__Internal*)__Instance)->fDamp = value;
            }
        }

        public float FWidth
        {
            get
            {
                return ((__Internal*)__Instance)->fWidth;
            }

            set
            {
                ((__Internal*)__Instance)->fWidth = value;
            }
        }

        public uint LMode
        {
            get
            {
                return ((__Internal*)__Instance)->lMode;
            }

            set
            {
                ((__Internal*)__Instance)->lMode = value;
            }
        }

        public int LChannel
        {
            get
            {
                return ((__Internal*)__Instance)->lChannel;
            }

            set
            {
                ((__Internal*)__Instance)->lChannel = value;
            }
        }
    }

    internal unsafe partial class bass_fx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_GetVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_FX_GetVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_TempoCreate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_FX_TempoCreate(uint chan, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_TempoGetSource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_FX_TempoGetSource(uint chan);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_TempoGetRateRatio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float BASS_FX_TempoGetRateRatio(uint chan);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_ReverseCreate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_FX_ReverseCreate(uint chan, float dec_block, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_ReverseGetSource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint BASS_FX_ReverseGetSource(uint chan);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_DecodeGet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float BASS_FX_BPM_DecodeGet(uint chan, double startSec, double endSec, uint minMaxBPM, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_CallbackSet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_CallbackSet(uint handle, __IntPtr proc, double period, uint minMaxBPM, uint flags, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_CallbackReset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_CallbackReset(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_Translate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float BASS_FX_BPM_Translate(uint handle, float val2tran, uint trans);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_Free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_Free(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatCallbackSet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatCallbackSet(uint handle, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatCallbackReset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatCallbackReset(uint handle);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatDecodeGet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatDecodeGet(uint chan, double startSec, double endSec, uint flags, __IntPtr proc, __IntPtr user);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatSetParameters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatSetParameters(uint handle, float bandwidth, float centerfreq, float beat_rtime);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatGetParameters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatGetParameters(uint handle, float* bandwidth, float* centerfreq, float* beat_rtime);

            [SuppressUnmanagedCodeSecurity, DllImport("bass_fx", EntryPoint = "BASS_FX_BPM_BeatFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BASS_FX_BPM_BeatFree(uint handle);
        }

        public static uint BASS_FX_GetVersion()
        {
            var __ret = __Internal.BASS_FX_GetVersion();
            return __ret;
        }

        public static uint BASS_FX_TempoCreate(uint chan, uint flags)
        {
            var __ret = __Internal.BASS_FX_TempoCreate(chan, flags);
            return __ret;
        }

        public static uint BASS_FX_TempoGetSource(uint chan)
        {
            var __ret = __Internal.BASS_FX_TempoGetSource(chan);
            return __ret;
        }

        public static float BASS_FX_TempoGetRateRatio(uint chan)
        {
            var __ret = __Internal.BASS_FX_TempoGetRateRatio(chan);
            return __ret;
        }

        public static uint BASS_FX_ReverseCreate(uint chan, float dec_block, uint flags)
        {
            var __ret = __Internal.BASS_FX_ReverseCreate(chan, dec_block, flags);
            return __ret;
        }

        public static uint BASS_FX_ReverseGetSource(uint chan)
        {
            var __ret = __Internal.BASS_FX_ReverseGetSource(chan);
            return __ret;
        }

        public static float BASS_FX_BPM_DecodeGet(uint chan, double startSec, double endSec, uint minMaxBPM, uint flags, __IntPtr proc, __IntPtr user)
        {
            var __arg5 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_FX_BPM_DecodeGet(chan, startSec, endSec, minMaxBPM, flags, __arg5, user);
            return __ret;
        }

        public static int BASS_FX_BPM_CallbackSet(uint handle, __IntPtr proc, double period, uint minMaxBPM, uint flags, __IntPtr user)
        {
            var __arg1 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_FX_BPM_CallbackSet(handle, __arg1, period, minMaxBPM, flags, user);
            return __ret;
        }

        public static int BASS_FX_BPM_CallbackReset(uint handle)
        {
            var __ret = __Internal.BASS_FX_BPM_CallbackReset(handle);
            return __ret;
        }

        public static float BASS_FX_BPM_Translate(uint handle, float val2tran, uint trans)
        {
            var __ret = __Internal.BASS_FX_BPM_Translate(handle, val2tran, trans);
            return __ret;
        }

        public static int BASS_FX_BPM_Free(uint handle)
        {
            var __ret = __Internal.BASS_FX_BPM_Free(handle);
            return __ret;
        }

        public static int BASS_FX_BPM_BeatCallbackSet(uint handle, __IntPtr proc, __IntPtr user)
        {
            var __arg1 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_FX_BPM_BeatCallbackSet(handle, __arg1, user);
            return __ret;
        }

        public static int BASS_FX_BPM_BeatCallbackReset(uint handle)
        {
            var __ret = __Internal.BASS_FX_BPM_BeatCallbackReset(handle);
            return __ret;
        }

        public static int BASS_FX_BPM_BeatDecodeGet(uint chan, double startSec, double endSec, uint flags, __IntPtr proc, __IntPtr user)
        {
            var __arg4 = proc == global::System.IntPtr.Zero ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(proc);
            var __ret = __Internal.BASS_FX_BPM_BeatDecodeGet(chan, startSec, endSec, flags, __arg4, user);
            return __ret;
        }

        public static int BASS_FX_BPM_BeatSetParameters(uint handle, float bandwidth, float centerfreq, float beat_rtime)
        {
            var __ret = __Internal.BASS_FX_BPM_BeatSetParameters(handle, bandwidth, centerfreq, beat_rtime);
            return __ret;
        }

        public static int BASS_FX_BPM_BeatGetParameters(uint handle, ref float bandwidth, ref float centerfreq, ref float beat_rtime)
        {
            fixed (float* __bandwidth1 = &bandwidth)
            {
                var __arg1 = __bandwidth1;
                fixed (float* __centerfreq2 = &centerfreq)
                {
                    var __arg2 = __centerfreq2;
                    fixed (float* __beat_rtime3 = &beat_rtime)
                    {
                        var __arg3 = __beat_rtime3;
                        var __ret = __Internal.BASS_FX_BPM_BeatGetParameters(handle, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static int BASS_FX_BPM_BeatFree(uint handle)
        {
            var __ret = __Internal.BASS_FX_BPM_BeatFree(handle);
            return __ret;
        }
    }
}
